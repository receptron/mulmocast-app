# QA Test Playbook for MulmoCast

MulmoCast の QA テスト作成・実行に関する知見集。
新しいテストを作成する際は、このドキュメントを参照すること。

---

## 1. テストファイルの基本構造

### 命名規則

```
test/manual_no_api_{feature_name}_qa.ts   # API コストなし、手動起動
test/manual_{feature_name}_qa.ts          # API コストあり、手動起動
test/automated_{feature_name}_test.ts     # CI/CD 向け、自動起動
```

### 必須要素

```typescript
// 1. ファイル先頭: JSDoc でテスト概要・使用方法・環境変数を記述
/**
 * {Feature} QA Test Suite
 *
 * Usage:
 *   1. Start the app: yarn start
 *   2. Run: npx tsx test/{filename}.ts
 *
 * Environment variables:
 *   CDP_URL  - CDP endpoint (default: http://localhost:9222/)
 *   APP_URL  - App URL fragment to match (default: localhost:5175)
 */

// 2. CONFIG オブジェクト: タイミング定数を一箇所に集約
const CONFIG = {
  CDP_RETRY_DELAY_MS: 1000,
  CDP_MAX_ATTEMPTS: 30,
  ACTION_DELAY_MS: 500,
  NAVIGATION_DELAY_MS: 1000,
  EDITOR_LOAD_DELAY_MS: 1500,
  SETTINGS_SAVE_DELAY_MS: 2000,
  PROJECT_CREATE_DELAY_MS: 3000,
  EDITOR_SETTLE_DELAY_MS: 1500,  // Monaco 用（後述）
} as const;

// 3. テスト結果の記録
interface TestResult {
  name: string;
  status: "PASS" | "FAIL" | "WARN";
  detail: string;
}

const results: TestResult[] = [];

function record(name: string, status: "PASS" | "FAIL" | "WARN", detail: string) {
  results.push({ name, status, detail });
  const icon = status === "PASS" ? "✓" : status === "FAIL" ? "✗" : "⚠";
  console.log(`  ${icon} [${status}] ${name}: ${detail}`);
}

// 4. CDP 接続 + アプリページ検索（共通パターン）
// 5. Console Monitor（共通パターン）
// 6. テスト関数群（Phase 分割）
// 7. メインの IIFE で実行 + サマリ出力
```

### テストプロジェクトの識別性

```typescript
const timestamp = new Date().toISOString().replace(/T/, " ").replace(/\..+/, "");
const runId = Date.now();
const TEST_PROJECT_TITLE = `[QA] {Feature} Test ${timestamp}`;
const TEST_PROJECT_DESCRIPTION = `Auto-generated by {filename}.ts (run ${runId}) – safe to delete`;
```

- タイトルに `[QA]` プレフィックスを付けて手動削除しやすくする
- `runId` でテストごとにユニークな値を生成

---

## 2. CDP 接続パターン

### 基本接続

```typescript
async function connectCDP(): Promise<Browser> {
  const cdpUrl = process.env.CDP_URL || "http://localhost:9222/";
  let attempts = 0;
  while (attempts < CONFIG.CDP_MAX_ATTEMPTS) {
    try {
      return await playwright.chromium.connectOverCDP(cdpUrl);
    } catch (error) {
      attempts++;
      if (attempts === CONFIG.CDP_MAX_ATTEMPTS) throw new Error(`Failed after ${attempts} attempts`);
      if (attempts === 1) console.log(`Connecting to ${cdpUrl}...`);
      await new Promise((r) => setTimeout(r, CONFIG.CDP_RETRY_DELAY_MS));
    }
  }
  throw new Error("Unreachable");
}
```

### アプリページの検索

```typescript
function findAppPage(contexts: BrowserContext[]): Page {
  const appUrl = process.env.APP_URL || "localhost:5175";
  for (const context of contexts) {
    const page = context.pages().find((p) => p.url().includes(appUrl));
    if (page) return page;
  }
  // fallback: 5173 も試す
  for (const context of contexts) {
    const page = context.pages().find((p) => p.url().includes("localhost:5173"));
    if (page) return page;
  }
  throw new Error("Could not find application page");
}
```

**注意**: Electron の dev server ポートは `5173` または `5175` のどちらかになる場合がある。

---

## 3. Monaco Editor との付き合い方

Monaco Editor は MulmoCast で最もテストが難しいコンポーネント。以下の知見を必ず守ること。

### EDITOR_SETTLE_DELAY_MS（必須）

Monaco はタブ切り替え時に非同期で diagnostics/validation を実行する。
タブ切り替え前に settle を待たないと `"Canceled"` エラーが発生する。

```typescript
// JSON タブから離れる前に必ず待つ
await page.waitForTimeout(CONFIG.EDITOR_SETTLE_DELAY_MS);
await navigateToStyleTab(page);
```

### JSON の読み取り

```typescript
async function readEditorJson(page: Page): Promise<Record<string, unknown> | null> {
  const content = await page.evaluate(() => {
    const editors = (window as any).monaco?.editor?.getEditors?.();
    return editors?.[0]?.getValue() ?? null;
  });
  if (!content) return null;
  try {
    return JSON.parse(content);
  } catch {
    return null;
  }
}
```

### JSON の書き込み

```typescript
async function writeEditorJson(page: Page, json: Record<string, unknown>): Promise<boolean> {
  // 1. エディタ内をクリック
  const viewLines = await page.$(".view-lines");
  if (!viewLines) return false;
  await viewLines.click();
  await page.waitForTimeout(300);

  // 2. 全選択 → クリップボード経由で貼り付け
  await page.keyboard.press(selectAllKey);
  await page.waitForTimeout(200);
  const newText = JSON.stringify(json, null, 2);
  await page.evaluate((t) => navigator.clipboard.writeText(t), newText);
  await page.waitForTimeout(200);
  await page.keyboard.press(pasteKey);

  // 3. Monaco 内部処理の完了を待つ（重要！）
  await page.waitForTimeout(2000);
  return true;
}
```

### JSON プロパティ順序の罠

Monaco の autocomplete が `images` のような配列プロパティの入力中に発火し、
意図しない補完が挿入されることがある。

**対策**: `vertexai_*` のような新規フィールドを `images` より前に配置する。

```typescript
// Bad: images の後に vertexai を追加 → autocomplete が発火する可能性
imageParams.vertexai_project = "...";

// Good: images を一時退避して vertexai を先に配置
const savedImages = imageParams.images;
delete imageParams.images;
imageParams.vertexai_project = "...";
imageParams.vertexai_location = "...";
if (savedImages !== undefined) imageParams.images = savedImages;
```

---

## 4. UI 操作パターン

### Reka UI Switch (トグル)

```typescript
// ラベルで検索してクリック
async function clickSwitchByLabel(page: Page, label: string): Promise<boolean> {
  const switches = await page.$$("button[role='switch']");
  for (const sw of switches) {
    const parent = await sw.evaluateHandle((el) => el.closest("div")?.parentElement);
    const text = await parent.evaluate((el) => el?.textContent || "");
    if (text.includes(label)) {
      await sw.click();
      return true;
    }
  }
  return false;
}

// 状態の取得
async function getSwitchStates(page: Page): Promise<Array<{ label: string; checked: boolean }>> {
  return page.evaluate(() => {
    return Array.from(document.querySelectorAll("button[role='switch']")).map((sw) => ({
      label: sw.closest("div")?.parentElement?.textContent?.trim() || "",
      checked: sw.getAttribute("data-state") === "checked",
    }));
  });
}
```

**注意**: `data-state === "checked"` で判定する（`aria-checked` ではない）。

### Reka UI Select (コンボボックス)

```typescript
async function clickComboboxByIndex(page: Page, index: number): Promise<void> {
  const triggers = await page.$$("button[role='combobox']");
  if (triggers[index]) await triggers[index].click();
}

async function selectOption(page: Page, optionText: string): Promise<boolean> {
  await page.waitForTimeout(300); // ドロップダウンのアニメーション待ち
  const options = await page.$$("[role='option']");
  for (const opt of options) {
    const text = await opt.textContent();
    if (text?.includes(optionText)) {
      await opt.click();
      return true;
    }
  }
  return false;
}
```

### タブの切り替え

```typescript
async function clickTabByText(page: Page, tabText: string): Promise<boolean> {
  const tabs = await page.$$("button[role='tab']");
  for (const tab of tabs) {
    const text = await tab.textContent();
    if (text?.includes(tabText)) {
      await tab.click();
      await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
      return true;
    }
  }
  return false;
}
```

**注意**: i18n 対応 - タブ名は言語設定によって異なる。英語前提で書くか、`data-testid` を使うこと。

### Settings モーダルの操作

```typescript
async function withSettingsModal(page: Page, callback: () => Promise<void>): Promise<boolean> {
  const settingsBtn = await page.$('[data-testid="settings-button"]');
  if (!settingsBtn) return false;
  await settingsBtn.click();
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  await callback();

  // Save ボタン → モーダルが自動で閉じる
  const saveBtn = await page.$('button:has-text("Save")');
  if (saveBtn) {
    await saveBtn.click();
    await page.waitForTimeout(CONFIG.SETTINGS_SAVE_DELAY_MS);
  }
  return true;
}
```

### スクロール

```typescript
async function scrollToH4(page: Page, heading: string): Promise<boolean> {
  const h4s = await page.$$("h4");
  for (const h4 of h4s) {
    const text = await h4.textContent();
    if (text?.includes(heading)) {
      await h4.scrollIntoViewIfNeeded();
      return true;
    }
  }
  return false;
}
```

---

## 5. Console Monitor パターン

テスト中のコンソールエラーを監視し、最後にヘルスチェックとして報告する。

```typescript
function createConsoleMonitor(page: Page): ConsoleMonitor {
  const monitor = {
    errors: [] as string[],
    warnings: [] as string[],
    deprecations: [] as string[],
    start: () => page.on("console", handler),
    stop: () => page.off("console", handler),
    reset: () => { /* 配列をクリア */ },
  };

  const handler = (msg: ConsoleMessage) => {
    const text = msg.text();
    if (msg.type() === "error") monitor.errors.push(text);
    if (msg.type() === "warning") monitor.warnings.push(text);
    if (text.toLowerCase().includes("deprecat")) monitor.deprecations.push(text);
  };

  return monitor;
}
```

### ヘルスチェック

```typescript
async function testConsoleHealth(monitor: ConsoleMonitor) {
  record("Console errors", monitor.errors.length === 0 ? "PASS" : "FAIL",
    monitor.errors.length === 0 ? "No errors" : `${monitor.errors.length} error(s)`);
  // エラー詳細を出力
  monitor.errors.forEach((e) => console.log(`    ERROR: ${e.substring(0, 200)}`));
}
```

---

## 6. テスト設計の原則

### Phase 分割

テストは論理的な Phase に分割する:

| Phase | 目的 | 例 |
|-------|------|-----|
| Setup | 前提条件の確立 | Settings クリア、Pro モード設定、テストプロジェクト作成 |
| Core Feature | 機能のメイン動作 | トグル ON/OFF、フィールド入力、プリフィル |
| Integration | 他機能との連携 | UI → JSON 反映、JSON → UI 反映 |
| Cleanup | 環境の復元 | テストデータの削除（任意） |
| Health | 副作用の確認 | コンソールエラーチェック |

### 双方向テスト

UI 変更が JSON に反映されるだけでなく、JSON 変更が UI に反映されることも必ずテストする。

### 空値テスト

Settings が空の状態で機能を操作する「blank defaults」テストを必ず含める。
空文字 `""` は JavaScript で falsy なので、`|| "default"` のようなフォールバックがバグを生む。

### テスト値のユニーク性

```typescript
const runId = Date.now();
const LOCATIONS = ["asia-northeast1", "us-west1", "europe-west4", "asia-southeast1"];
const TEST_LOCATION = LOCATIONS[runId % LOCATIONS.length];
```

毎回異なる値を使うことで、前回のテストデータが残っていても誤検知しない。

---

## 7. サマリ出力

```typescript
// テスト終了時の標準サマリ
const passed = results.filter((r) => r.status === "PASS").length;
const failed = results.filter((r) => r.status === "FAIL").length;
const warned = results.filter((r) => r.status === "WARN").length;

console.log(`\n${"=".repeat(50)}`);
console.log(`  Results: ${passed} PASS / ${failed} FAIL / ${warned} WARN`);
console.log(`${"=".repeat(50)}`);

if (failed > 0) {
  console.log("\nFailed tests:");
  results.filter((r) => r.status === "FAIL").forEach((r) => {
    console.log(`  ✗ ${r.name}: ${r.detail}`);
  });
}
```

---

## 8. 既知の落とし穴

### Monaco "Canceled" エラー
- **原因**: タブ切り替え時に Monaco の非同期処理（diagnostics, validation）が中断される
- **対策**: `EDITOR_SETTLE_DELAY_MS` を待ってからタブを切り替える

### Reka UI の model-value パターン
- `checked` ではなく `model-value` を使う（プロジェクト CLAUDE.md に詳細）
- テストでは `data-state="checked"` で状態を判定

### i18n 依存のセレクタ
- タブ名やボタンラベルが言語設定で変わる
- `data-testid` が存在する要素はそちらを優先
- `button:has-text("...")` は英語前提の場合、言語が日本語だと失敗する

### Electron の dev server ポート
- `5173` と `5175` の両方にフォールバックする
- 環境変数 `APP_URL` でオーバーライド可能

### 空文字の falsy 判定
- `""` は falsy → `|| "default"` でバグになる
- `vertexai_project === ""` のときに `"us-central1"` が入るバグが実際に発生した
- 修正: `?? "default"` を使うか、明示的に `undefined` チェック

### Settings モーダルの Save 後
- Save ボタンクリック後、モーダルが閉じるまでの delay が必要
- `SETTINGS_SAVE_DELAY_MS: 2000` が安全な値

### 見出しテキストの不一致
- コンポーネントの見出しが想定と異なる場合がある（例: "Advanced Settings" vs "Advanced Beat Settings"）
- テスト前に `browser_snapshot` で実際の DOM テキストを確認すること
- 複数の表記に対応する場合は OR 条件で検索する

### Checkbox の隣接テキスト
- Reka UI の Checkbox は `label` タグではなく sibling の `div`（generic）にテキストが入る場合がある
- `parentElement.textContent` で検索するのが安全
- `label.textContent` に頼ると見つからないケースがある

---

## 9. MCP Playwright でのデバッグ時の注意

QA テスト作成中に MCP Playwright で動作確認する場合:

- `browser_snapshot` は DOM 全体を返すため巨大（230K+ 文字の事例あり）。`browser_evaluate` や `browser_take_screenshot` を優先
- 操作間に適切な delay を入れること（最低 500ms）
- Settings モーダルが開いている状態で他の操作をすると予期しない動作になる

---

## 更新履歴

- 2026-02-10: 初版作成（Vertex AI QA + Electron Upgrade QA の知見から）
- 2026-02-21: 見出しテキスト不一致・Checkbox 隣接テキストの落とし穴を追加（Speed Option QA の知見から）
