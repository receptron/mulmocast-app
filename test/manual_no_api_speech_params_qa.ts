/**
 * Speech Parameters QA Test Suite
 *
 * Creates one speaker per provider via the UI, then tests all applicable
 * fields (combobox round-trip, input round-trip, beat-level override)
 * with bidirectional UI↔JSON verification.
 *
 * Usage:
 *   1. Start the Electron app: yarn start
 *   2. Run the test:  npx tsx test/manual_no_api_speech_params_qa.ts
 *
 * Environment Variables:
 *   CDP_URL  – Override CDP endpoint (default: http://localhost:9222/)
 *   APP_URL  – Override app page URL match (default: localhost:5175)
 */

import playwright, { type Browser, type BrowserContext, type Page, type ConsoleMessage } from "playwright";

// =====================================================================
// Config & Constants
// =====================================================================

const CONFIG = {
  CDP_RETRY_DELAY_MS: 1000,
  CDP_MAX_ATTEMPTS: 30,
  ACTION_DELAY_MS: 500,
  NAVIGATION_DELAY_MS: 1000,
  EDITOR_LOAD_DELAY_MS: 1500,
  EDITOR_SETTLE_DELAY_MS: 1500,
  PROJECT_CREATE_DELAY_MS: 3000,
} as const;

const timestamp = new Date().toISOString().replace(/T/, " ").replace(/\..+/, "");
const runId = Date.now();
const TEST_PROJECT_TITLE = `[QA] Speech Params Test ${timestamp}`;
const TEST_PROJECT_DESCRIPTION = `Auto-generated by manual_no_api_speech_params_qa.ts (run ${runId}) – safe to delete`;

/** Default speaker created by Zod schema default – always OpenAI. */
const DEFAULT_SPEAKER = "Presenter";

/** Speakers to add via the UI (provider display name used to select). */
const EXTRA_SPEAKERS: Array<{ name: string; providerDisplay: string }> = [
  { name: "google", providerDisplay: "Google" },
  { name: "elevenlabs", providerDisplay: "ElevenLabs" },
  { name: "gemini", providerDisplay: "Gemini" },
  { name: "kotodama", providerDisplay: "Kotodama" },
];

// =====================================================================
// Results
// =====================================================================

interface TestResult {
  name: string;
  status: "PASS" | "FAIL" | "WARN";
  detail: string;
}
const results: TestResult[] = [];

function record(name: string, status: "PASS" | "FAIL" | "WARN", detail: string) {
  results.push({ name, status, detail });
  const icon = status === "PASS" ? "✓" : status === "FAIL" ? "✗" : "⚠";
  console.log(`  ${icon} [${status}] ${name}: ${detail}`);
}

// =====================================================================
// Infrastructure
// =====================================================================

async function connectCDP(): Promise<Browser> {
  const cdpUrl = process.env.CDP_URL || "http://localhost:9222/";
  let attempts = 0;
  while (attempts < CONFIG.CDP_MAX_ATTEMPTS) {
    try {
      const browser = await playwright.chromium.connectOverCDP(cdpUrl);
      console.log("✓ Connected to CDP");
      return browser;
    } catch (error: unknown) {
      attempts++;
      if (attempts === CONFIG.CDP_MAX_ATTEMPTS)
        throw new Error(
          `Failed after ${CONFIG.CDP_MAX_ATTEMPTS} attempts: ${error instanceof Error ? error.message : String(error)}`,
          { cause: error },
        );
      if (attempts === 1) console.log(`Connecting to ${cdpUrl}...`);
      await new Promise((r) => setTimeout(r, CONFIG.CDP_RETRY_DELAY_MS));
    }
  }
  throw new Error("Unreachable");
}

function findAppPage(contexts: BrowserContext[]): Page {
  const appUrl = process.env.APP_URL || "localhost:5175";
  for (const ctx of contexts) {
    const p = ctx.pages().find((pg) => pg.url().includes(appUrl));
    if (p) return p;
  }
  for (const ctx of contexts) {
    const p = ctx.pages().find((pg) => pg.url().includes("localhost:5173"));
    if (p) return p;
  }
  throw new Error("Could not find application page");
}

// =====================================================================
// Console Monitor
// =====================================================================

interface ConsoleMonitor {
  errors: string[];
  warnings: string[];
  start: () => void;
  stop: () => void;
}

function createConsoleMonitor(page: Page): ConsoleMonitor {
  const monitor: ConsoleMonitor = {
    errors: [],
    warnings: [],
    start: () => page.on("console", handler),
    stop: () => page.off("console", handler),
  };
  const handler = (msg: ConsoleMessage) => {
    if (msg.type() === "error") monitor.errors.push(msg.text());
    if (msg.type() === "warning") monitor.warnings.push(msg.text());
  };
  return monitor;
}

// =====================================================================
// Generic Helpers
// =====================================================================

const selectAllKey = process.platform === "darwin" ? "Meta+a" : "Control+a";
const copyKey = process.platform === "darwin" ? "Meta+c" : "Control+c";
const pasteKey = process.platform === "darwin" ? "Meta+v" : "Control+v";

async function clickTabByText(page: Page, tabText: string): Promise<boolean> {
  const tabs = await page.locator('[role="tab"]').all();
  for (const tab of tabs) {
    const text = (await tab.textContent())?.trim() || "";
    if (text === tabText || text.startsWith(tabText)) {
      await tab.click();
      await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
      return true;
    }
  }
  return false;
}

async function navigateToStyleTab(page: Page): Promise<boolean> {
  return (await clickTabByText(page, "スタイル")) || (await clickTabByText(page, "Style"));
}

async function navigateToBeatTab(page: Page): Promise<boolean> {
  const tabs = await page.locator('[role="tab"]').all();
  for (const tab of tabs) {
    const text = (await tab.textContent())?.trim() || "";
    if (text.startsWith("BEAT")) {
      await tab.click();
      await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
      return true;
    }
  }
  return false;
}

async function scrollToSpeechParams(page: Page): Promise<boolean> {
  return page.evaluate(() => {
    const h4s = document.querySelectorAll("h4");
    for (const el of h4s) {
      const t = el.textContent?.trim() || "";
      if (t === "Speech Parameters" || t === "音声設定") {
        el.scrollIntoView({ behavior: "instant", block: "start" });
        return true;
      }
    }
    return false;
  });
}

/** Scroll a specific speaker section into view. */
async function scrollToSpeaker(page: Page, speakerName: string): Promise<boolean> {
  return page.evaluate((name) => {
    const h5s = document.querySelectorAll("h5");
    for (const h5 of h5s) {
      if (h5.textContent?.trim() !== name) continue;
      const section = h5.closest(".rounded.border");
      if (section) {
        section.scrollIntoView({ behavior: "instant", block: "start" });
        return true;
      }
    }
    return false;
  }, speakerName);
}

/** Navigate to Style tab → Speech Parameters → speaker section. */
async function toStyleSpeaker(page: Page, speakerName: string): Promise<void> {
  await page.waitForTimeout(CONFIG.EDITOR_SETTLE_DELAY_MS);
  await navigateToStyleTab(page);
  await scrollToSpeaker(page, speakerName);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
}

/** Navigate to JSON tab and wait for editor to load. */
async function toJson(page: Page): Promise<void> {
  await page.waitForTimeout(CONFIG.EDITOR_SETTLE_DELAY_MS);
  await clickTabByText(page, "JSON");
  await page.waitForTimeout(CONFIG.EDITOR_LOAD_DELAY_MS);
}

// =====================================================================
// Monaco Helpers
// =====================================================================

async function readEditorJson(page: Page): Promise<Record<string, unknown> | null> {
  const viewLines = await page.$(".monaco-editor .view-lines");
  if (!viewLines) return null;
  await viewLines.click();
  await page.waitForTimeout(300);
  await page.keyboard.press(selectAllKey);
  await page.waitForTimeout(200);
  await page.keyboard.press(copyKey);
  await page.waitForTimeout(200);
  const text = await page.evaluate(() => navigator.clipboard.readText());
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

async function writeEditorJson(page: Page, json: Record<string, unknown>): Promise<boolean> {
  const viewLines = await page.$(".monaco-editor .view-lines");
  if (!viewLines) return false;
  await viewLines.click();
  await page.waitForTimeout(300);
  await page.keyboard.press(selectAllKey);
  await page.waitForTimeout(200);
  await page.evaluate((t) => navigator.clipboard.writeText(t), JSON.stringify(json, null, 2));
  await page.waitForTimeout(200);
  await page.keyboard.press(pasteKey);
  await page.waitForTimeout(2000);
  return true;
}

// =====================================================================
// JSON Data Helpers
// =====================================================================

function getSpeakers(json: Record<string, unknown>): Record<string, Record<string, unknown>> {
  const sp = (json.speechParams || (json.presentationStyle as Record<string, unknown>)?.speechParams) as
    | Record<string, unknown>
    | undefined;
  return (sp?.speakers || {}) as Record<string, Record<string, unknown>>;
}

function getSpeaker(json: Record<string, unknown>, name: string): Record<string, unknown> {
  return getSpeakers(json)[name] || {};
}

function getSpeechOptions(speaker: Record<string, unknown>): Record<string, unknown> {
  if (!speaker.speechOptions) speaker.speechOptions = {};
  return speaker.speechOptions as Record<string, unknown>;
}

function getFirstBeat(json: Record<string, unknown>): Record<string, unknown> | undefined {
  return (json.beats as Array<Record<string, unknown>> | undefined)?.[0];
}

// =====================================================================
// Speaker Setup Helpers (UI-driven)
// =====================================================================

/** Verify that the default speaker (Presenter) exists in the Speech Parameters section. */
async function verifyDefaultSpeakerExists(page: Page): Promise<boolean> {
  return page.evaluate(() => {
    const h5s = document.querySelectorAll("h5");
    for (const h5 of h5s) {
      if (h5.textContent?.trim() === "Presenter") return true;
    }
    return false;
  });
}

/** Type a speaker name and click "Add Speaker". */
async function addSpeakerUI(page: Page, name: string): Promise<boolean> {
  const typed = await page.evaluate((speakerName) => {
    const inputs = document.querySelectorAll("input");
    for (const inp of inputs) {
      const ph = inp.getAttribute("placeholder") || "";
      if (ph.includes("Speaker name") || ph.includes("スピーカー名")) {
        const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")?.set;
        if (setter) {
          setter.call(inp, speakerName);
          inp.dispatchEvent(new Event("input", { bubbles: true }));
          return true;
        }
      }
    }
    return false;
  }, name);
  if (!typed) return false;
  await page.waitForTimeout(300);

  const clicked = await page.evaluate(() => {
    const btns = document.querySelectorAll("button");
    for (const b of btns) {
      const t = b.textContent?.trim() || "";
      if ((t.includes("Add") && t.includes("Speaker")) || t.includes("スピーカーを追加")) {
        if (!(b as HTMLButtonElement).disabled) {
          (b as HTMLElement).click();
          return true;
        }
      }
    }
    return false;
  });
  if (!clicked) return false;
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  return true;
}

// =====================================================================
// Speaker-Scoped Combobox Helpers
// =====================================================================

/**
 * Find the global index of a combobox inside a speaker section, identified by label text.
 * Pass labelText = null to get the first combobox (= Provider).
 */
async function findSpeakerCombobox(page: Page, speakerName: string, labelText: string | null): Promise<number> {
  return page.evaluate(
    ({ speaker, label }) => {
      const h5s = document.querySelectorAll("h5");
      for (const h5 of h5s) {
        if (h5.textContent?.trim() !== speaker) continue;
        const section = h5.closest(".rounded.border");
        if (!section) continue;

        if (label === null) {
          // First combobox in section = Provider
          const combo = section.querySelector('[role="combobox"]');
          if (!combo) continue;
          const all = document.querySelectorAll('[role="combobox"]');
          for (let i = 0; i < all.length; i++) if (all[i] === combo) return i;
        } else {
          const labels = section.querySelectorAll("label");
          for (const l of labels) {
            if (l.textContent?.trim() !== label) continue;
            const container = l.closest("div");
            if (!container) continue;
            const combo = container.querySelector('[role="combobox"]');
            if (!combo) continue;
            const all = document.querySelectorAll('[role="combobox"]');
            for (let i = 0; i < all.length; i++) if (all[i] === combo) return i;
          }
        }
      }
      return -1;
    },
    { speaker: speakerName, label: labelText },
  );
}

async function clickSpeakerCombobox(page: Page, speakerName: string, labelText: string | null): Promise<boolean> {
  const idx = await findSpeakerCombobox(page, speakerName, labelText);
  if (idx < 0) return false;
  await page.locator('[role="combobox"]').nth(idx).click({ force: true });
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  return true;
}

async function getSpeakerComboboxText(page: Page, speakerName: string, labelText: string): Promise<string> {
  const idx = await findSpeakerCombobox(page, speakerName, labelText);
  if (idx < 0) return "";
  return (await page.locator('[role="combobox"]').nth(idx).textContent())?.trim() || "";
}

async function selectOptionByPrefix(page: Page, prefix: string): Promise<boolean> {
  await page.waitForTimeout(300);
  const options = await page.locator('[role="option"]').all();
  for (const opt of options) {
    const text = (await opt.textContent())?.trim() || "";
    if (text.startsWith(prefix)) {
      await opt.click({ force: true });
      await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
      return true;
    }
  }
  await page.keyboard.press("Escape");
  await page.waitForTimeout(300);
  return false;
}

async function selectDifferentOption(page: Page, currentText: string): Promise<string | null> {
  await page.waitForTimeout(300);
  const options = await page.locator('[role="option"]').all();
  for (const opt of options) {
    const text = (await opt.textContent())?.trim() || "";
    if (text && text !== currentText) {
      await opt.click({ force: true });
      await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
      return text;
    }
  }
  await page.keyboard.press("Escape");
  await page.waitForTimeout(300);
  return null;
}

/** Set the provider of a speaker section. */
async function setSpeakerProviderUI(page: Page, speakerName: string, providerDisplay: string): Promise<boolean> {
  const ok = await clickSpeakerCombobox(page, speakerName, null);
  if (!ok) return false;
  return selectOptionByPrefix(page, providerDisplay);
}

// =====================================================================
// Speaker-Scoped Input Helpers
// =====================================================================

interface InputInfo {
  visible: boolean;
  value: string;
  min: string;
  max: string;
  step: string;
  placeholder: string;
}

/** Get input info scoped to a speaker section. */
async function getSpeakerInput(page: Page, speakerName: string, labelText: string): Promise<InputInfo> {
  return page.evaluate(
    ({ speaker, label }) => {
      const h5s = document.querySelectorAll("h5");
      for (const h5 of h5s) {
        if (h5.textContent?.trim() !== speaker) continue;
        const section = h5.closest(".rounded.border");
        if (!section) continue;
        const labels = section.querySelectorAll("label");
        for (const l of labels) {
          if (l.textContent?.trim() !== label) continue;
          // Walk up to find input (handles tooltip wrapper div.group)
          let el = l.parentElement;
          for (let d = 0; el && d < 3; d++, el = el.parentElement) {
            const input = el.querySelector("input");
            if (input) {
              return {
                visible: true,
                value: input.value || "",
                min: input.getAttribute("min") || "",
                max: input.getAttribute("max") || "",
                step: input.getAttribute("step") || "",
                placeholder: input.getAttribute("placeholder") || "",
              };
            }
          }
        }
      }
      return { visible: false, value: "", min: "", max: "", step: "", placeholder: "" };
    },
    { speaker: speakerName, label: labelText },
  );
}

/** Set input value scoped to a speaker section. */
async function setSpeakerInput(page: Page, speakerName: string, labelText: string, value: string): Promise<boolean> {
  return page.evaluate(
    ({ speaker, label, val }) => {
      const h5s = document.querySelectorAll("h5");
      for (const h5 of h5s) {
        if (h5.textContent?.trim() !== speaker) continue;
        const section = h5.closest(".rounded.border");
        if (!section) continue;
        const labels = section.querySelectorAll("label");
        for (const l of labels) {
          if (l.textContent?.trim() !== label) continue;
          // Walk up to find input (handles tooltip wrapper div.group)
          let el = l.parentElement;
          for (let d = 0; el && d < 3; d++, el = el.parentElement) {
            const input = el.querySelector("input");
            if (input) {
              const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")?.set;
              if (setter) {
                setter.call(input, val);
                input.dispatchEvent(new Event("input", { bubbles: true }));
                return true;
              }
            }
          }
        }
      }
      return false;
    },
    { speaker: speakerName, label: labelText, val: value },
  );
}

// =====================================================================
// Field Visibility (speaker-scoped)
// =====================================================================

interface FieldVisibility {
  speed: boolean;
  instruction: boolean;
  stability: boolean;
  similarityBoost: boolean;
  model: boolean;
  decoration: boolean;
}

async function getSpeakerFieldVisibility(page: Page, speakerName: string): Promise<FieldVisibility> {
  return page.evaluate(
    ({ speaker, fieldLabels }) => {
      const h5s = document.querySelectorAll("h5");
      let section: Element | null = null;
      for (const h5 of h5s) {
        if (h5.textContent?.trim() === speaker) {
          section = h5.closest(".rounded.border");
          break;
        }
      }
      if (!section)
        return {
          speed: false,
          instruction: false,
          stability: false,
          similarityBoost: false,
          model: false,
          decoration: false,
        };

      const result: Record<string, boolean> = {};
      for (const [key, texts] of Object.entries(fieldLabels)) {
        let found = false;
        for (const labelText of texts as string[]) {
          if (found) break;
          const labels = section.querySelectorAll("label");
          for (const l of labels) {
            if (l.textContent?.trim() !== labelText) continue;
            // Walk up to find input/combobox (handles tooltip wrapper div.group)
            let el = l.parentElement;
            for (let d = 0; el && d < 3; d++, el = el.parentElement) {
              if (el.querySelector("input") || el.querySelector('[role="combobox"]')) {
                found = true;
                break;
              }
            }
            if (found) break;
          }
        }
        result[key] = found;
      }
      return result as unknown;
    },
    {
      speaker: speakerName,
      fieldLabels: {
        speed: ["Reading Speed", "読み上げの速さ"],
        instruction: ["Reading Style", "読み上げのスタイル"],
        stability: ["Stability", "安定性"],
        similarityBoost: ["Similarity Boost"],
        model: ["Model", "モデル"],
        decoration: ["Voice Style", "声のスタイル"],
      },
    },
  ) as Promise<FieldVisibility>;
}

// =====================================================================
// Beat Override Helpers
// =====================================================================

async function openBeatAdvancedSettings(page: Page): Promise<boolean> {
  return page.evaluate(() => {
    const headings = document.querySelectorAll("h4");
    for (const h of headings) {
      const t = h.textContent?.trim() || "";
      if (t === "Advanced Beat Settings" || t === "Advanced Settings" || t === "詳細設定") {
        const collapsible = h.closest("[data-state]");
        if (collapsible?.getAttribute("data-state") === "open") return true;
        (h.closest("div") as HTMLElement)?.click();
        return true;
      }
    }
    return false;
  });
}

async function toggleBeatSpeechOverride(page: Page, enable: boolean): Promise<boolean> {
  return page.evaluate((shouldEnable) => {
    const checkboxes = document.querySelectorAll('[role="checkbox"]');
    for (const cb of checkboxes) {
      const parent = cb.parentElement;
      if (!parent) continue;
      const text = parent.textContent?.trim() || "";
      if (text.toLowerCase().includes("speech") || text.includes("音声オプション")) {
        const isChecked = cb.getAttribute("data-state") === "checked";
        if (isChecked !== shouldEnable) (cb as HTMLElement).click();
        return true;
      }
    }
    return false;
  }, enable);
}

/** Get the current state of the speech override checkbox. */
async function getBeatSpeechOverrideState(page: Page): Promise<boolean | null> {
  return page.evaluate(() => {
    const checkboxes = document.querySelectorAll('[role="checkbox"]');
    for (const cb of checkboxes) {
      const parent = cb.parentElement;
      if (!parent) continue;
      const text = parent.textContent?.trim() || "";
      if (text.toLowerCase().includes("speech") || text.includes("音声オプション")) {
        return cb.getAttribute("data-state") === "checked";
      }
    }
    return null;
  });
}

async function getBeatInput(page: Page, labelText: string): Promise<InputInfo> {
  return page.evaluate((label) => {
    const labels = document.querySelectorAll("label");
    for (const l of labels) {
      if (l.textContent?.trim() !== label) continue;
      const card = l.closest('[class*="rounded-xl"], [class*="card"]');
      if (!card) continue;
      // Walk up to find input (handles tooltip wrapper div.group)
      let el = l.parentElement;
      for (let d = 0; el && d < 3; d++, el = el.parentElement) {
        const input = el.querySelector("input") as HTMLInputElement | null;
        if (input) {
          return {
            visible: true,
            value: input.value || "",
            min: input.getAttribute("min") || "",
            max: input.getAttribute("max") || "",
            step: input.getAttribute("step") || "",
            placeholder: input.getAttribute("placeholder") || "",
          };
        }
      }
    }
    return { visible: false, value: "", min: "", max: "", step: "", placeholder: "" };
  }, labelText);
}

async function setBeatInput(page: Page, labelText: string, value: string): Promise<boolean> {
  return page.evaluate(
    ({ label, val }) => {
      const labels = document.querySelectorAll("label");
      for (const l of labels) {
        if (l.textContent?.trim() !== label) continue;
        const card = l.closest('[class*="rounded-xl"], [class*="card"]');
        if (!card) continue;
        // Walk up to find input (handles tooltip wrapper div.group)
        let el = l.parentElement;
        for (let d = 0; el && d < 3; d++, el = el.parentElement) {
          const input = el.querySelector("input") as HTMLInputElement | null;
          if (input) {
            const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")?.set;
            if (setter) {
              setter.call(input, val);
              input.dispatchEvent(new Event("input", { bubbles: true }));
              return true;
            }
          }
        }
      }
      return false;
    },
    { label: labelText, val: value },
  );
}

// =====================================================================
// High-Level Reusable Test Functions
// =====================================================================

/**
 * Test a combobox (select dropdown) round-trip: UI→JSON and JSON→UI.
 * @param speakerName    - h5 text identifying the speaker section in the UI
 * @param speakerKey     - key in JSON speechParams.speakers
 * @param label          - i18n label of the combobox (e.g. "Voice ID")
 * @param jsonField      - field name on the speaker object (e.g. "voiceId")
 * @param jsonTestValue  - value to set in JSON for JSON→UI test
 * @param expectedDisplay - expected display text after setting jsonTestValue
 */
async function testComboboxRoundTrip(
  page: Page,
  prefix: string,
  speakerName: string,
  speakerKey: string,
  label: string,
  jsonField: string,
  jsonTestValue: string,
  expectedDisplay: string,
): Promise<void> {
  // --- UI→JSON ---
  // Read current JSON value before UI change for strict comparison
  await toJson(page);
  const json0 = await readEditorJson(page);
  const origValue = json0 ? getSpeaker(json0, speakerKey)[jsonField] : undefined;
  await toStyleSpeaker(page, speakerName);

  const beforeText = await getSpeakerComboboxText(page, speakerName, label);
  const clickOk = await clickSpeakerCombobox(page, speakerName, label);
  if (!clickOk) {
    record(`${prefix} ${label} UI→JSON`, "FAIL", "Combobox not found");
    return;
  }
  const newText = await selectDifferentOption(page, beforeText);
  if (!newText) {
    record(`${prefix} ${label} UI→JSON`, "FAIL", "No different option");
    return;
  }

  await toJson(page);
  const json1 = await readEditorJson(page);
  if (json1) {
    const speaker = getSpeaker(json1, speakerKey);
    const val = speaker[jsonField];
    // Round-trip verify: go back to Style, combobox should show newText
    // (Vue re-renders from JSON on tab switch, so wrong value = wrong display)
    await toStyleSpeaker(page, speakerName);
    const verifyText = await getSpeakerComboboxText(page, speakerName, label);
    record(
      `${prefix} ${label} UI→JSON`,
      val !== origValue && verifyText === newText ? "PASS" : "FAIL",
      `"${beforeText}" → "${newText}", JSON=${val}, verify="${verifyText}"`,
    );
  } else {
    record(`${prefix} ${label} UI→JSON`, "FAIL", "Could not read JSON");
  }

  // --- JSON→UI ---
  await toJson(page);
  const json2 = await readEditorJson(page);
  if (json2) {
    const speaker = getSpeaker(json2, speakerKey);
    speaker[jsonField] = jsonTestValue;
    await writeEditorJson(page, json2);
    await toStyleSpeaker(page, speakerName);
    const displayText = await getSpeakerComboboxText(page, speakerName, label);
    record(
      `${prefix} ${label} JSON→UI`,
      displayText === expectedDisplay ? "PASS" : "FAIL",
      `Set "${jsonTestValue}" → expected="${expectedDisplay}", actual="${displayText}"`,
    );
  } else {
    await toStyleSpeaker(page, speakerName);
  }
}

/**
 * Test a combobox stored in speechOptions (e.g. decoration).
 */
async function testSpeechOptionsComboboxRoundTrip(
  page: Page,
  prefix: string,
  speakerName: string,
  speakerKey: string,
  label: string,
  jsonField: string,
  jsonTestValue: string,
  expectedDisplay: string,
): Promise<void> {
  // --- UI→JSON ---
  // Read current JSON value before UI change for strict comparison
  await toJson(page);
  const json0 = await readEditorJson(page);
  const origValue = json0
    ? (getSpeaker(json0, speakerKey).speechOptions as Record<string, unknown> | undefined)?.[jsonField]
    : undefined;
  await toStyleSpeaker(page, speakerName);

  const beforeText = await getSpeakerComboboxText(page, speakerName, label);
  const clickOk = await clickSpeakerCombobox(page, speakerName, label);
  if (!clickOk) {
    record(`${prefix} ${label} UI→JSON`, "FAIL", "Combobox not found");
    return;
  }
  const newText = await selectDifferentOption(page, beforeText);
  if (!newText) {
    record(`${prefix} ${label} UI→JSON`, "FAIL", "No different option");
    return;
  }

  await toJson(page);
  const json1 = await readEditorJson(page);
  if (json1) {
    const so = getSpeaker(json1, speakerKey).speechOptions as Record<string, unknown> | undefined;
    const val = so?.[jsonField];
    // Round-trip verify: go back to Style, combobox should show newText
    await toStyleSpeaker(page, speakerName);
    const verifyText = await getSpeakerComboboxText(page, speakerName, label);
    record(
      `${prefix} ${label} UI→JSON`,
      val !== origValue && verifyText === newText ? "PASS" : "FAIL",
      `"${beforeText}" → "${newText}", JSON=${val}, verify="${verifyText}"`,
    );
  } else {
    record(`${prefix} ${label} UI→JSON`, "FAIL", "Could not read JSON");
  }

  // --- JSON→UI ---
  await toJson(page);
  const json2 = await readEditorJson(page);
  if (json2) {
    const speaker = getSpeaker(json2, speakerKey);
    const so = getSpeechOptions(speaker);
    so[jsonField] = jsonTestValue;
    await writeEditorJson(page, json2);
    await toStyleSpeaker(page, speakerName);
    const displayText = await getSpeakerComboboxText(page, speakerName, label);
    record(
      `${prefix} ${label} JSON→UI`,
      displayText === expectedDisplay ? "PASS" : "FAIL",
      `Set "${jsonTestValue}" → expected="${expectedDisplay}", actual="${displayText}"`,
    );
  } else {
    await toStyleSpeaker(page, speakerName);
  }
}

/**
 * Test an input field round-trip: attributes check, UI→JSON, JSON→UI, clear.
 * @param speakerName  - h5 text identifying the speaker section
 * @param speakerKey   - key in JSON speechParams.speakers
 * @param label        - i18n label (e.g. "Reading Speed")
 * @param jsonField    - field in speechOptions (e.g. "speed")
 * @param uiValue      - value to type into the input for UI→JSON
 * @param jsonValue     - value to set in JSON for JSON→UI
 * @param expectedAttrs - optional attribute checks (min, max, step, placeholder)
 */
async function testInputRoundTrip(
  page: Page,
  prefix: string,
  speakerName: string,
  speakerKey: string,
  label: string,
  jsonField: string,
  uiValue: string,
  jsonValue: number | string,
  expectedAttrs?: { min?: string; max?: string; step?: string; placeholderContains?: string },
): Promise<void> {
  // --- Attribute check ---
  if (expectedAttrs) {
    const info = await getSpeakerInput(page, speakerName, label);
    if (!info.visible) {
      record(`${prefix} ${label} visible`, "FAIL", "Not visible");
      return;
    }
    record(`${prefix} ${label} visible`, "PASS", "Visible");
    if (expectedAttrs.min !== undefined)
      record(`${prefix} ${label} min`, info.min === expectedAttrs.min ? "PASS" : "FAIL", `actual="${info.min}"`);
    if (expectedAttrs.max !== undefined)
      record(`${prefix} ${label} max`, info.max === expectedAttrs.max ? "PASS" : "FAIL", `actual="${info.max}"`);
    if (expectedAttrs.step !== undefined)
      record(`${prefix} ${label} step`, info.step === expectedAttrs.step ? "PASS" : "FAIL", `actual="${info.step}"`);
    if (expectedAttrs.placeholderContains !== undefined)
      record(
        `${prefix} ${label} placeholder`,
        info.placeholder.includes(expectedAttrs.placeholderContains) ? "PASS" : "FAIL",
        `actual="${info.placeholder}"`,
      );
  }

  // --- UI→JSON ---
  const setOk = await setSpeakerInput(page, speakerName, label, uiValue);
  if (!setOk) {
    record(`${prefix} ${label} UI→JSON`, "FAIL", "Input not found");
    return;
  }
  await toJson(page);
  const json1 = await readEditorJson(page);
  if (json1) {
    const so = getSpeaker(json1, speakerKey).speechOptions as Record<string, unknown> | undefined;
    const actual = so?.[jsonField];
    const expected = typeof jsonValue === "number" ? Number(uiValue) : uiValue;
    record(
      `${prefix} ${label} UI→JSON`,
      actual == expected ? "PASS" : "FAIL",
      `expected=${expected}, actual=${actual}`,
    );
  }

  // --- JSON→UI ---
  const json2 = json1 || (await readEditorJson(page));
  if (json2) {
    const speaker = getSpeaker(json2, speakerKey);
    const so = getSpeechOptions(speaker);
    so[jsonField] = jsonValue;
    await writeEditorJson(page, json2);
    await toStyleSpeaker(page, speakerName);
    const info = await getSpeakerInput(page, speakerName, label);
    record(
      `${prefix} ${label} JSON→UI`,
      info.value === String(jsonValue) ? "PASS" : "FAIL",
      `expected="${jsonValue}", actual="${info.value}"`,
    );
  } else {
    await toStyleSpeaker(page, speakerName);
  }

  // --- Clear ---
  const clearOk = await setSpeakerInput(page, speakerName, label, "");
  if (!clearOk) {
    record(`${prefix} ${label} clear`, "FAIL", "Input not found");
    return;
  }
  await toJson(page);
  const json3 = await readEditorJson(page);
  if (json3) {
    const so = getSpeaker(json3, speakerKey).speechOptions as Record<string, unknown> | undefined;
    const hasField = so && jsonField in so;
    record(
      `${prefix} ${label} clear`,
      !hasField ? "PASS" : "FAIL",
      !hasField ? "Removed from JSON" : `Still present: ${so?.[jsonField]}`,
    );
  }
  await toStyleSpeaker(page, speakerName);
}

/**
 * Test beat-level override with bulk set/verify:
 *   1. UI→JSON: enable override → set ALL fields → verify ALL in JSON
 *   2. Override OFF → verify speechOptions removed
 *   3. JSON→UI: write ALL fields to JSON → verify checkbox ON + ALL field values in UI
 *   4. Clean up
 *
 * @param speakerKey - JSON speaker key (also used to assign beat.speaker)
 * @param fields - all applicable fields for this provider
 */
async function testBeatOverride(
  page: Page,
  prefix: string,
  speakerKey: string,
  fields: Array<{ label: string; jsonField: string; testValue: string }>,
): Promise<void> {
  const bp = `${prefix} Beat`;

  // Assign the beat to this speaker via JSON
  await toJson(page);
  const jsonSetup = await readEditorJson(page);
  if (jsonSetup) {
    const beat = getFirstBeat(jsonSetup);
    if (beat) {
      beat.speaker = speakerKey;
      await writeEditorJson(page, jsonSetup);
    }
  }

  // --- UI→JSON: Set all params at once, verify all in JSON ---
  await page.waitForTimeout(CONFIG.EDITOR_SETTLE_DELAY_MS);
  const beatOk = await navigateToBeatTab(page);
  if (!beatOk) {
    record(`${bp} navigate`, "FAIL", "BEAT tab not found");
    return;
  }

  await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await openBeatAdvancedSettings(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Enable speech override
  const toggleOk = await toggleBeatSpeechOverride(page, true);
  record(`${bp} enable override`, toggleOk ? "PASS" : "FAIL", toggleOk ? "Enabled" : "Checkbox not found");
  if (!toggleOk) return;
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Batch set all field values
  const setFailures: string[] = [];
  for (const f of fields) {
    const setOk = await setBeatInput(page, f.label, f.testValue);
    if (!setOk) setFailures.push(f.label);
  }
  if (setFailures.length > 0) {
    record(`${bp} set fields`, "FAIL", `Could not set: ${setFailures.join(", ")}`);
  }

  // Verify all fields in JSON at once
  await toJson(page);
  const json = await readEditorJson(page);
  if (json) {
    const beat = getFirstBeat(json);
    const so = beat?.speechOptions as Record<string, unknown> | undefined;
    for (const f of fields) {
      const val = so?.[f.jsonField];
      const expected = Number(f.testValue) || f.testValue;
      record(`${bp} UI→JSON ${f.label}`, val == expected ? "PASS" : "FAIL", `expected=${expected}, actual=${val}`);
    }
  }

  // --- Override OFF: verify speechOptions removed ---
  await navigateToBeatTab(page);
  await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await openBeatAdvancedSettings(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await toggleBeatSpeechOverride(page, false);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  await toJson(page);
  const json2 = await readEditorJson(page);
  if (json2) {
    const beat = getFirstBeat(json2);
    const hasSO = beat && "speechOptions" in beat;
    record(`${bp} override OFF`, !hasSO ? "PASS" : "FAIL", !hasSO ? "speechOptions removed" : "Still present");
  }

  // --- JSON→UI: Write all params to JSON, verify checkbox ON and all field values ---
  const jsonValues: Record<string, number | string> = {};
  for (const f of fields) {
    jsonValues[f.jsonField] = Number(f.testValue) || f.testValue;
  }

  await toJson(page);
  const json3 = await readEditorJson(page);
  if (json3) {
    const beat = getFirstBeat(json3);
    if (beat) {
      beat.speechOptions = jsonValues;
      await writeEditorJson(page, json3);
    }
  }

  await page.waitForTimeout(CONFIG.EDITOR_SETTLE_DELAY_MS);
  await navigateToBeatTab(page);
  await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await openBeatAdvancedSettings(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Verify checkbox is ON
  const cbState = await getBeatSpeechOverrideState(page);
  record(`${bp} JSON→UI checkbox`, cbState === true ? "PASS" : "FAIL", `expected=checked, actual=${cbState}`);

  // Verify all field values at once
  for (const f of fields) {
    const info = await getBeatInput(page, f.label);
    const expected = String(jsonValues[f.jsonField]);
    record(
      `${bp} JSON→UI ${f.label}`,
      info.visible && info.value === expected ? "PASS" : "FAIL",
      `expected="${expected}", actual="${info.value}", visible=${info.visible}`,
    );
  }

  // Clean up: disable override
  await toggleBeatSpeechOverride(page, false);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
}

/**
 * Test that changing one field in beat override doesn't affect other fields.
 * Sets all fields via JSON, changes one via UI, verifies others are unchanged in both UI and JSON.
 *
 * @param speakerKey - JSON speaker key
 * @param fields - all fields with their initial values
 * @param changeField - the single field to modify
 */
async function testBeatPartialUpdate(
  page: Page,
  prefix: string,
  speakerKey: string,
  fields: Array<{ label: string; jsonField: string; initialValue: string }>,
  changeField: { label: string; jsonField: string; newValue: string },
): Promise<void> {
  const bp = `${prefix} Beat partial`;

  // Set all initial values via JSON
  await toJson(page);
  const jsonSetup = await readEditorJson(page);
  if (jsonSetup) {
    const beat = getFirstBeat(jsonSetup);
    if (beat) {
      beat.speaker = speakerKey;
      const so: Record<string, number | string> = {};
      for (const f of fields) {
        so[f.jsonField] = Number(f.initialValue) || f.initialValue;
      }
      beat.speechOptions = so;
      await writeEditorJson(page, jsonSetup);
    }
  }

  // Navigate to BEAT tab
  await page.waitForTimeout(CONFIG.EDITOR_SETTLE_DELAY_MS);
  await navigateToBeatTab(page);
  await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await openBeatAdvancedSettings(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Change only one field via UI
  const setOk = await setBeatInput(page, changeField.label, changeField.newValue);
  if (!setOk) {
    record(`${bp} set ${changeField.label}`, "FAIL", "Input not found");
    return;
  }

  // Verify in UI: changed field has new value, others unchanged
  for (const f of fields) {
    const info = await getBeatInput(page, f.label);
    const expected = f.jsonField === changeField.jsonField ? changeField.newValue : f.initialValue;
    record(
      `${bp} UI ${f.label}`,
      info.visible && info.value === expected ? "PASS" : "FAIL",
      `expected="${expected}", actual="${info.value}"`,
    );
  }

  // Verify in JSON: changed field has new value, others unchanged
  await toJson(page);
  const json = await readEditorJson(page);
  if (json) {
    const beat = getFirstBeat(json);
    const so = beat?.speechOptions as Record<string, unknown> | undefined;
    for (const f of fields) {
      const val = so?.[f.jsonField];
      const expected =
        f.jsonField === changeField.jsonField
          ? Number(changeField.newValue) || changeField.newValue
          : Number(f.initialValue) || f.initialValue;
      record(`${bp} JSON ${f.label}`, val == expected ? "PASS" : "FAIL", `expected=${expected}, actual=${val}`);
    }
  }

  // Clean up: disable override
  await navigateToBeatTab(page);
  await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await openBeatAdvancedSettings(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await toggleBeatSpeechOverride(page, false);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
}

// =====================================================================
// Test Phases
// =====================================================================

async function phase1Setup(page: Page): Promise<boolean> {
  console.log("\n=== Phase 1: Setup ===");

  await page.goto(page.url().split("#")[0] + "#/");
  await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);

  // Close any overlay
  const overlay = await page.$('[data-state="open"][aria-hidden="true"]');
  if (overlay) {
    await page.keyboard.press("Escape");
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  }

  // Create project
  const newBtn = await page.$('[data-testid="create-new-button"]');
  if (!newBtn) {
    record("Setup", "FAIL", "Create button not found");
    return false;
  }
  await newBtn.click();
  await page.waitForTimeout(CONFIG.PROJECT_CREATE_DELAY_MS);
  const created = page.url().includes("#/project/");
  record("Create project", created ? "PASS" : "FAIL", `URL: ${page.url()}`);
  if (!created) return false;

  // Set title via JSON
  await clickTabByText(page, "JSON");
  await page.waitForTimeout(CONFIG.EDITOR_LOAD_DELAY_MS);
  const json = await readEditorJson(page);
  if (json) {
    json.title = TEST_PROJECT_TITLE;
    json.description = TEST_PROJECT_DESCRIPTION;
    await writeEditorJson(page, json);
    record("Set title", "PASS", `"${TEST_PROJECT_TITLE}"`);
  }

  // Go to Style tab → Speech Parameters
  await page.waitForTimeout(CONFIG.EDITOR_SETTLE_DELAY_MS);
  await navigateToStyleTab(page);
  await scrollToSpeechParams(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // New projects always have speechParams with a default "Presenter" speaker (Zod schema default).
  const hasPresenter = await verifyDefaultSpeakerExists(page);
  record("Default speaker", hasPresenter ? "PASS" : "FAIL", hasPresenter ? `"${DEFAULT_SPEAKER}" exists` : "Not found");
  if (!hasPresenter) return false;
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Add extra speakers and set their providers
  for (const sp of EXTRA_SPEAKERS) {
    // Scroll to bottom of Speech Parameters to find the Add input
    await page.evaluate(() => {
      const h4s = document.querySelectorAll("h4");
      for (const h4 of h4s) {
        const t = h4.textContent?.trim() || "";
        if (t === "Speech Parameters" || t === "音声設定") {
          const card = h4.closest('[class*="p-4"]');
          if (card) card.scrollIntoView({ behavior: "instant", block: "end" });
        }
      }
    });
    await page.waitForTimeout(300);

    const added = await addSpeakerUI(page, sp.name);
    record(`Add speaker "${sp.name}"`, added ? "PASS" : "FAIL", added ? "Added" : "Failed");
    if (!added) continue;
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    // Set provider
    await scrollToSpeaker(page, sp.name);
    await page.waitForTimeout(300);
    const provSet = await setSpeakerProviderUI(page, sp.name, sp.providerDisplay);
    record(`Set ${sp.name} → ${sp.providerDisplay}`, provSet ? "PASS" : "FAIL", provSet ? "OK" : "Failed");
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  }

  return true;
}

async function phase2FieldVisibility(page: Page): Promise<void> {
  console.log("\n=== Phase 2: Field Visibility Matrix ===");

  const expectations: Array<{
    speakerName: string;
    speed: boolean;
    instruction: boolean;
    stability: boolean;
    similarityBoost: boolean;
    model: boolean;
    decoration: boolean;
  }> = [
    {
      speakerName: DEFAULT_SPEAKER,
      speed: true,
      instruction: true,
      stability: false,
      similarityBoost: false,
      model: false,
      decoration: false,
    },
    {
      speakerName: "google",
      speed: true,
      instruction: false,
      stability: false,
      similarityBoost: false,
      model: false,
      decoration: false,
    },
    {
      speakerName: "elevenlabs",
      speed: true,
      instruction: false,
      stability: true,
      similarityBoost: true,
      model: true,
      decoration: false,
    },
    {
      speakerName: "gemini",
      speed: false,
      instruction: true,
      stability: false,
      similarityBoost: false,
      model: true,
      decoration: false,
    },
    {
      speakerName: "kotodama",
      speed: false,
      instruction: false,
      stability: false,
      similarityBoost: false,
      model: false,
      decoration: true,
    },
  ];

  for (const exp of expectations) {
    console.log(`\n--- ${exp.speakerName} ---`);
    await scrollToSpeaker(page, exp.speakerName);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
    const vis = await getSpeakerFieldVisibility(page, exp.speakerName);
    const checks: Array<[string, boolean, boolean]> = [
      ["speed", vis.speed, exp.speed],
      ["instruction", vis.instruction, exp.instruction],
      ["stability", vis.stability, exp.stability],
      ["similarityBoost", vis.similarityBoost, exp.similarityBoost],
      ["model", vis.model, exp.model],
      ["decoration", vis.decoration, exp.decoration],
    ];
    for (const [field, actual, expected] of checks) {
      record(
        `${exp.speakerName} ${field}`,
        actual === expected ? "PASS" : "FAIL",
        `expected=${expected ? "visible" : "hidden"}, actual=${actual ? "visible" : "hidden"}`,
      );
    }
  }
}

async function phase3OpenAI(page: Page): Promise<void> {
  console.log("\n=== Phase 3: OpenAI (Presenter) ===");
  const P = "OpenAI";
  const S = DEFAULT_SPEAKER;
  const K = DEFAULT_SPEAKER;
  await scrollToSpeaker(page, S);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // voiceId round-trip
  await testComboboxRoundTrip(page, P, S, K, "Voice ID", "voiceId", "alloy", "Alloy");

  // speed round-trip (OpenAI: 0.25–4.0, step 0.25)
  await testInputRoundTrip(page, P, S, K, "Reading Speed", "speed", "2.5", 3.0, {
    min: "0.25",
    max: "4",
    step: "0.25",
    placeholderContains: "0.25",
  });

  // instruction round-trip
  await testInputRoundTrip(page, P, S, K, "Reading Style", "instruction", "Read slowly", "Be cheerful");

  // beat-level override (OpenAI supports speed + instruction)
  await testBeatOverride(page, P, K, [
    { label: "Reading Speed", jsonField: "speed", testValue: "1.5" },
    { label: "Reading Style", jsonField: "instruction", testValue: "Fast pace" },
  ]);
}

async function phase4Google(page: Page): Promise<void> {
  console.log("\n=== Phase 4: Google ===");
  const P = "Google";
  const S = "google";
  const K = "google";
  await toStyleSpeaker(page, S);

  // voiceId round-trip
  await testComboboxRoundTrip(page, P, S, K, "Voice ID", "voiceId", "en-US-Standard-A", "US Standard A (Male)");

  // speed round-trip (Google: 0.25–2.0, step 0.25)
  await testInputRoundTrip(page, P, S, K, "Reading Speed", "speed", "1.5", 1.75, {
    min: "0.25",
    max: "2",
    step: "0.25",
    placeholderContains: "0.25",
  });

  // beat-level override (Google supports speed only)
  await testBeatOverride(page, P, K, [{ label: "Reading Speed", jsonField: "speed", testValue: "1.25" }]);
}

async function phase5ElevenLabs(page: Page): Promise<void> {
  console.log("\n=== Phase 5: ElevenLabs ===");
  const P = "ElevenLabs";
  const S = "elevenlabs";
  const K = "elevenlabs";
  await toStyleSpeaker(page, S);

  // model round-trip
  await testComboboxRoundTrip(page, P, S, K, "Model", "model", "eleven_multilingual_v2", "eleven_multilingual_v2");

  // voiceId round-trip
  await testComboboxRoundTrip(page, P, S, K, "Voice ID", "voiceId", "c6SfcYrb2t09NHXiT80T", "Janathan");

  // speed round-trip (ElevenLabs: 0.7–1.2, step 0.1)
  await testInputRoundTrip(page, P, S, K, "Reading Speed", "speed", "1.0", 0.9, {
    min: "0.7",
    max: "1.2",
    step: "0.1",
    placeholderContains: "0.7",
  });

  // stability round-trip
  await testInputRoundTrip(page, P, S, K, "Stability", "stability", "0.5", 0.7);

  // similarity_boost round-trip
  await testInputRoundTrip(page, P, S, K, "Similarity Boost", "similarity_boost", "0.8", 0.6);

  // beat-level override (ElevenLabs supports speed + stability + similarity_boost)
  await testBeatOverride(page, P, K, [
    { label: "Reading Speed", jsonField: "speed", testValue: "1.1" },
    { label: "Stability", jsonField: "stability", testValue: "0.4" },
    { label: "Similarity Boost", jsonField: "similarity_boost", testValue: "0.9" },
  ]);

  // Partial update: change speed only, verify stability and similarity_boost unchanged
  await testBeatPartialUpdate(
    page,
    P,
    K,
    [
      { label: "Reading Speed", jsonField: "speed", initialValue: "1.1" },
      { label: "Stability", jsonField: "stability", initialValue: "0.4" },
      { label: "Similarity Boost", jsonField: "similarity_boost", initialValue: "0.9" },
    ],
    { label: "Reading Speed", jsonField: "speed", newValue: "0.8" },
  );
}

async function phase6Gemini(page: Page): Promise<void> {
  console.log("\n=== Phase 6: Gemini ===");
  const P = "Gemini";
  const S = "gemini";
  const K = "gemini";
  await toStyleSpeaker(page, S);

  // model round-trip
  await testComboboxRoundTrip(
    page,
    P,
    S,
    K,
    "Model",
    "model",
    "gemini-2.5-flash-preview-tts",
    "gemini-2.5-flash-preview-tts",
  );

  // voiceId round-trip
  await testComboboxRoundTrip(page, P, S, K, "Voice ID", "voiceId", "Puck", "Puck (Upbeat)");

  // instruction round-trip
  await testInputRoundTrip(page, P, S, K, "Reading Style", "instruction", "Speak with energy", "Calm and steady");

  // beat-level override (Gemini supports instruction only)
  await testBeatOverride(page, P, K, [
    { label: "Reading Style", jsonField: "instruction", testValue: "Whisper softly" },
  ]);
}

async function phase7Kotodama(page: Page): Promise<void> {
  console.log("\n=== Phase 7: Kotodama ===");
  const P = "Kotodama";
  const S = "kotodama";
  const K = "kotodama";
  await toStyleSpeaker(page, S);

  // voiceId round-trip
  await testComboboxRoundTrip(page, P, S, K, "Voice ID", "voiceId", "Poporo", "Poporo");

  // decoration round-trip (combobox stored in speechOptions.decoration)
  await testSpeechOptionsComboboxRoundTrip(page, P, S, K, "Voice Style", "decoration", "happy", "Happy");
}

async function phase8ConsoleHealth(monitor: ConsoleMonitor): Promise<void> {
  console.log("\n=== Phase 8: Console Health ===");
  record("Console errors", monitor.errors.length === 0 ? "PASS" : "WARN", `${monitor.errors.length} error(s)`);
  if (monitor.errors.length > 0) {
    console.log(`    Errors: ${monitor.errors.slice(0, 5).join("; ")}`);
  }
}

// =====================================================================
// Main
// =====================================================================

(async () => {
  console.log("========================================");
  console.log("  Speech Parameters QA Test Suite");
  console.log(`  ${timestamp}`);
  console.log(`  Run ID: ${runId}`);
  console.log(`  Project: "${TEST_PROJECT_TITLE}"`);
  console.log("========================================\n");

  let exitCode = 1;

  try {
    const browser = await connectCDP();
    const page = findAppPage(browser.contexts());
    console.log(`App page: ${page.url()}`);

    // Inject __name polyfill for tsx/esbuild compatibility with page.evaluate
    await page.evaluate("window.__name = window.__name || function(fn){ return fn; }");

    const monitor = createConsoleMonitor(page);
    monitor.start();

    const setupOk = await phase1Setup(page);
    if (setupOk) {
      await phase2FieldVisibility(page);
      await phase3OpenAI(page);
      await phase4Google(page);
      await phase5ElevenLabs(page);
      await phase6Gemini(page);
      await phase7Kotodama(page);
    }

    monitor.stop();
    await phase8ConsoleHealth(monitor);

    // Summary
    console.log("\n========================================");
    console.log("  Summary");
    console.log("========================================");
    const pass = results.filter((r) => r.status === "PASS").length;
    const fail = results.filter((r) => r.status === "FAIL").length;
    const warn = results.filter((r) => r.status === "WARN").length;
    console.log(`  PASS: ${pass}  |  FAIL: ${fail}  |  WARN: ${warn}  |  Total: ${results.length}`);

    if (fail > 0) {
      console.log("\n  Failed tests:");
      results.filter((r) => r.status === "FAIL").forEach((r) => console.log(`    ✗ ${r.name}: ${r.detail}`));
    }

    exitCode = fail > 0 ? 1 : 0;
  } catch (error: unknown) {
    console.error("\nFatal error:", error instanceof Error ? error.message : String(error));
  }

  console.log(`\nExit code: ${exitCode}`);
  process.exit(exitCode);
})();
