/**
 * Vertex AI Support QA Test Suite
 *
 * Manual test script to verify Vertex AI integration in the MulmoCast app.
 * Connects to a running Electron app via CDP and validates:
 *
 *   Phase 1 – Setup
 *     1a. Settings page: clear Vertex AI defaults (blank)
 *     1b. Ensure Pro mode
 *     Create test project
 *
 *   Phase 2 – Blank defaults (Settings blank)
 *     2a. Image Params: non-Google hidden → Google → toggle ON blank → empty fields → OFF
 *     3a. Movie Params: non-Google hidden → Google → toggle ON blank → empty fields → OFF
 *
 *   Phase 3 – Prefill (Settings values set)
 *     1c. Settings: set project ID + location
 *     2b. Image Params: toggle ON → pre-filled → OFF → ON (leave ON for JSON)
 *     3b. Movie Params: toggle ON → pre-filled → OFF → ON (leave ON for JSON)
 *
 *   Phase 4 – Per-beat (blank + prefill)
 *     4. Per-beat: custom imageParams → Vertex AI blank → prefill
 *
 *   Phase 5 – Integration
 *     5. JSON Editor: UI → JSON reflection
 *     6. JSON → UI reflection
 *     7. Provider switch hides toggle
 *     8. Console health
 *
 * Usage:
 *   1. Start the app: yarn start
 *   2. Run: npx tsx test/manual_no_api_vertex_ai_qa.ts
 *
 * Environment variables:
 *   CDP_URL  - CDP endpoint (default: http://localhost:9222/)
 *   APP_URL  - App URL fragment to match (default: localhost:5175)
 */
import playwright, { Browser, BrowserContext, ConsoleMessage, Page } from "playwright-core";

const CONFIG = {
  CDP_RETRY_DELAY_MS: 1000,
  CDP_MAX_ATTEMPTS: 30,
  ACTION_DELAY_MS: 500,
  NAVIGATION_DELAY_MS: 1000,
  EDITOR_LOAD_DELAY_MS: 1500,
  SETTINGS_SAVE_DELAY_MS: 2000,
  PROJECT_CREATE_DELAY_MS: 3000,
} as const;

const timestamp = new Date().toISOString().replace(/T/, " ").replace(/\..+/, "");
const runId = Date.now();
const TEST_PROJECT_TITLE = `[QA] Vertex AI Test ${timestamp}`;
const TEST_PROJECT_DESCRIPTION = `Auto-generated by manual_no_api_vertex_ai_qa.ts (run ${runId}) – safe to delete`;
const TEST_PROJECT_ID = `qa-project-${runId}`;
const LOCATIONS = ["asia-northeast1", "us-west1", "europe-west4", "asia-southeast1"];
const TEST_LOCATION = LOCATIONS[runId % LOCATIONS.length];
const JSON_EDIT_PROJECT_ID = `json-edit-${runId}`;
const JSON_EDIT_LOCATION = "europe-west1";

interface TestResult {
  name: string;
  status: "PASS" | "FAIL" | "WARN";
  detail: string;
}

const results: TestResult[] = [];

function record(name: string, status: "PASS" | "FAIL" | "WARN", detail: string) {
  results.push({ name, status, detail });
  const icon = status === "PASS" ? "\u2713" : status === "FAIL" ? "\u2717" : "\u26a0";
  console.log(`  ${icon} [${status}] ${name}: ${detail}`);
}

// --- Infrastructure ---

async function connectCDP(): Promise<Browser> {
  const cdpUrl = process.env.CDP_URL || "http://localhost:9222/";
  let attempts = 0;

  while (attempts < CONFIG.CDP_MAX_ATTEMPTS) {
    try {
      const browser = await playwright.chromium.connectOverCDP(cdpUrl);
      console.log("\u2713 Connected to CDP");
      return browser;
    } catch (error: unknown) {
      attempts++;
      if (attempts === CONFIG.CDP_MAX_ATTEMPTS) {
        throw new Error(
          `Failed to connect after ${CONFIG.CDP_MAX_ATTEMPTS} attempts: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
      if (attempts === 1) {
        console.log(`Connecting to ${cdpUrl}...`);
      }
      await new Promise((resolve) => setTimeout(resolve, CONFIG.CDP_RETRY_DELAY_MS));
    }
  }
  throw new Error("Unreachable");
}

function findAppPage(contexts: BrowserContext[]): Page {
  const appUrl = process.env.APP_URL || "localhost:5175";
  for (const context of contexts) {
    const page = context.pages().find((p) => p.url().includes(appUrl));
    if (page) return page;
  }
  // fallback: try 5173
  for (const context of contexts) {
    const page = context.pages().find((p) => p.url().includes("localhost:5173"));
    if (page) return page;
  }
  throw new Error("Could not find application page");
}

// --- Console Monitoring ---

interface ConsoleMonitor {
  errors: string[];
  warnings: string[];
  start: () => void;
  stop: () => void;
  reset: () => void;
}

function createConsoleMonitor(page: Page): ConsoleMonitor {
  const monitor: ConsoleMonitor = {
    errors: [],
    warnings: [],
    start: () => {
      page.on("console", handler);
    },
    stop: () => {
      page.off("console", handler);
    },
    reset: () => {
      monitor.errors = [];
      monitor.warnings = [];
    },
  };

  const handler = (msg: ConsoleMessage) => {
    const text = msg.text();
    const type = msg.type();
    if (type === "error") {
      monitor.errors.push(text);
    }
    if (type === "warning") {
      monitor.warnings.push(text);
    }
  };

  return monitor;
}

// --- Helpers ---

const selectAllKey = process.platform === "darwin" ? "Meta+a" : "Control+a";
const copyKey = process.platform === "darwin" ? "Meta+c" : "Control+c";
const pasteKey = process.platform === "darwin" ? "Meta+v" : "Control+v";

async function clickTabByText(page: Page, tabText: string): Promise<boolean> {
  const tabs = await page.locator('[role="tab"]').all();
  for (const tab of tabs) {
    const text = await tab.textContent();
    if (text?.trim() === tabText) {
      await tab.click();
      await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
      return true;
    }
  }
  return false;
}

async function scrollToH4(page: Page, heading: string): Promise<boolean> {
  return page.evaluate((h) => {
    const h4s = document.querySelectorAll("h4");
    for (const el of h4s) {
      if (el.textContent?.trim() === h) {
        el.scrollIntoView({ behavior: "instant", block: "start" });
        return true;
      }
    }
    return false;
  }, heading);
}

async function getComboboxTexts(page: Page): Promise<string[]> {
  return page.evaluate(() => {
    const selects = document.querySelectorAll('[role="combobox"]');
    return Array.from(selects).map((s) => s.textContent?.trim() || "");
  });
}

/**
 * Find the global index of the first combobox inside the card that contains the given h4 heading.
 */
async function findComboboxIndexInSection(page: Page, heading: string): Promise<number> {
  return page.evaluate((h) => {
    const h4s = document.querySelectorAll("h4");
    for (const h4 of h4s) {
      if (h4.textContent?.trim() === h) {
        // Walk up to find the Card container
        const card = h4.closest(".p-4, [class*='card']") || h4.parentElement?.parentElement;
        if (!card) continue;
        // Find first combobox inside this card
        const combo = card.querySelector('[role="combobox"]');
        if (!combo) continue;
        // Find its global index
        const allCombos = document.querySelectorAll('[role="combobox"]');
        for (let i = 0; i < allCombos.length; i++) {
          if (allCombos[i] === combo) return i;
        }
      }
    }
    return -1;
  }, heading);
}

async function clickComboboxByIndex(page: Page, index: number): Promise<void> {
  await page.locator('[role="combobox"]').nth(index).click({ force: true });
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
}

async function selectOption(page: Page, optionText: string): Promise<boolean> {
  // Wait for dropdown to appear
  await page.waitForTimeout(300);
  const option = page.locator('[role="option"]').filter({ hasText: new RegExp(`^${optionText}$`) });
  const count = await option.count();
  if (count > 0) {
    await option.first().click({ force: true });
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
    return true;
  }
  // Close dropdown if option not found
  await page.keyboard.press("Escape");
  await page.waitForTimeout(300);
  return false;
}

async function getSwitchStates(page: Page): Promise<Array<{ label: string; checked: boolean }>> {
  return page.evaluate(() => {
    const switches = document.querySelectorAll('[role="switch"]');
    return Array.from(switches).map((s) => {
      const label = s.closest("div")?.querySelector("label")?.textContent || "";
      return { label, checked: s.getAttribute("data-state") === "checked" };
    });
  });
}

async function clickSwitchByLabel(page: Page, label: string): Promise<boolean> {
  const clicked = await page.evaluate((lbl) => {
    const switches = document.querySelectorAll('[role="switch"]');
    for (const sw of switches) {
      const parentLabel = sw.closest("div")?.querySelector("label")?.textContent || "";
      if (parentLabel.includes(lbl)) {
        (sw as HTMLElement).click();
        return true;
      }
    }
    return false;
  }, label);
  if (clicked) {
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  }
  return clicked;
}

/**
 * Click the nth Vertex AI switch (1-based index).
 */
async function clickNthVertexAISwitch(page: Page, nth: number): Promise<boolean> {
  const clicked = await page.evaluate((n) => {
    const switches = document.querySelectorAll('[role="switch"]');
    let count = 0;
    for (const sw of switches) {
      const label = sw.closest("div")?.querySelector("label")?.textContent || "";
      if (label.includes("Vertex AI")) {
        count++;
        if (count === n) {
          (sw as HTMLElement).click();
          return true;
        }
      }
    }
    return false;
  }, nth);
  if (clicked) {
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  }
  return clicked;
}

async function getInputValues(page: Page): Promise<Array<{ placeholder: string; value: string }>> {
  return page.evaluate(() => {
    const inputs = document.querySelectorAll("input[type='text'], input:not([type])");
    return Array.from(inputs).map((input) => ({
      placeholder: (input as HTMLInputElement).getAttribute("placeholder") || "",
      value: (input as HTMLInputElement).value || "",
    }));
  });
}

async function setInputByPlaceholder(page: Page, placeholder: string, value: string): Promise<boolean> {
  return page.evaluate(
    ({ ph, val }) => {
      const inputs = document.querySelectorAll("input");
      for (const input of inputs) {
        if (input.getAttribute("placeholder") === ph) {
          const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")?.set;
          if (setter) {
            setter.call(input, val);
            input.dispatchEvent(new Event("input", { bubbles: true }));
            return true;
          }
        }
      }
      return false;
    },
    { ph: placeholder, val: value },
  );
}

async function clearInputByPlaceholder(page: Page, placeholder: string): Promise<boolean> {
  return setInputByPlaceholder(page, placeholder, "");
}

async function readEditorJson(page: Page): Promise<Record<string, unknown> | null> {
  const viewLines = await page.$(".monaco-editor .view-lines");
  if (!viewLines) return null;
  await viewLines.click();
  await page.waitForTimeout(300);
  await page.keyboard.press(selectAllKey);
  await page.waitForTimeout(200);
  await page.keyboard.press(copyKey);
  await page.waitForTimeout(200);
  const text = await page.evaluate(() => navigator.clipboard.readText());
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

async function writeEditorJson(page: Page, json: Record<string, unknown>): Promise<boolean> {
  const viewLines = await page.$(".monaco-editor .view-lines");
  if (!viewLines) return false;
  await viewLines.click();
  await page.waitForTimeout(300);
  await page.keyboard.press(selectAllKey);
  await page.waitForTimeout(200);
  const newText = JSON.stringify(json, null, 2);
  await page.evaluate((t) => navigator.clipboard.writeText(t), newText);
  await page.waitForTimeout(200);
  await page.keyboard.press(pasteKey);
  await page.waitForTimeout(1000);
  return true;
}

/** Open settings modal, run callback, close modal */
async function withSettingsModal(page: Page, callback: () => Promise<void>): Promise<boolean> {
  const settingsBtn = await page.$('[data-testid="settings-button"]');
  if (!settingsBtn) {
    record("Settings button", "FAIL", "Settings button not found");
    return false;
  }
  await settingsBtn.click();
  await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);

  const langSelect = await page.$('[data-testid="language-select"]');
  if (!langSelect) {
    record("Settings modal opened", "FAIL", "Modal did not open");
    return false;
  }

  await callback();

  // Wait for debounced save, then close
  await page.waitForTimeout(CONFIG.SETTINGS_SAVE_DELAY_MS);
  await page.keyboard.press("Escape");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  return true;
}

/** Expand the Vertex AI collapsible in settings if not already expanded */
async function expandVertexAISection(page: Page): Promise<boolean> {
  return page.evaluate(() => {
    const buttons = document.querySelectorAll("button");
    for (const btn of buttons) {
      if (btn.textContent?.includes("Vertex AI")) {
        // Check if already expanded by looking at data-state
        const collapsible = btn.closest("[data-state]");
        if (collapsible?.getAttribute("data-state") === "open") return true;
        btn.click();
        return true;
      }
    }
    return false;
  });
}

async function navigateToStyleTab(page: Page): Promise<boolean> {
  return (await clickTabByText(page, "\u30b9\u30bf\u30a4\u30eb")) || (await clickTabByText(page, "Style"));
}

async function scrollToImageParams(page: Page): Promise<boolean> {
  return (await scrollToH4(page, "\u753b\u50cf\u751f\u6210\u8a2d\u5b9a")) || (await scrollToH4(page, "Image Parameters"));
}

async function scrollToMovieParams(page: Page): Promise<boolean> {
  return (await scrollToH4(page, "\u52d5\u753b\u751f\u6210\u8a2d\u5b9a")) || (await scrollToH4(page, "Movie Parameters"));
}

async function findImageProviderIndex(page: Page): Promise<number> {
  let idx = await findComboboxIndexInSection(page, "\u753b\u50cf\u751f\u6210\u8a2d\u5b9a");
  if (idx < 0) idx = await findComboboxIndexInSection(page, "Image Parameters");
  return idx;
}

async function findMovieProviderIndex(page: Page): Promise<number> {
  let idx = await findComboboxIndexInSection(page, "\u52d5\u753b\u751f\u6210\u8a2d\u5b9a");
  if (idx < 0) idx = await findComboboxIndexInSection(page, "Movie Parameters");
  return idx;
}

/** Count Vertex AI toggles currently visible */
async function countVertexAIToggles(page: Page): Promise<number> {
  const switches = await getSwitchStates(page);
  return switches.filter((s) => s.label.includes("Vertex AI")).length;
}

// --- Test Cases ---

/**
 * Test 1a: Settings – Verify Vertex AI section exists and fields are present.
 *          Clear any existing values (blank defaults).
 */
async function testSettingsBlankDefaults(page: Page) {
  console.log("\n=== 1a. Settings - Blank Vertex AI Defaults ===");

  await withSettingsModal(page, async () => {
    record("Settings modal opened", "PASS", "Found");

    // Check Vertex AI section exists
    const vertexAIExists = await page.evaluate(() => {
      const buttons = document.querySelectorAll("button");
      return Array.from(buttons).some((b) => b.textContent?.includes("Vertex AI"));
    });
    record("Vertex AI section exists", vertexAIExists ? "PASS" : "FAIL", vertexAIExists ? "Found" : "Not found");
    if (!vertexAIExists) return;

    // Expand Vertex AI section
    await expandVertexAISection(page);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    // Check input fields
    const inputs = await getInputValues(page);
    const projectInput = inputs.find((i) => i.placeholder === "your-gcp-project-id");
    const locationInput = inputs.find((i) => i.placeholder === "us-central1");

    record("Project ID field", projectInput ? "PASS" : "FAIL", projectInput ? "Found" : "Not found");
    record("Location field", locationInput ? "PASS" : "FAIL", locationInput ? "Found" : "Not found");

    // Clear values to test blank defaults
    await clearInputByPlaceholder(page, "your-gcp-project-id");
    await clearInputByPlaceholder(page, "us-central1");
    record("Cleared Vertex AI fields", "PASS", "Set project and location to blank");
  });
}

/**
 * Test 1c: Settings – Set Vertex AI project ID and location values.
 */
async function testSettingsSetValues(page: Page) {
  console.log("\n=== 1c. Settings - Set Vertex AI Values ===");
  console.log(`  Test values: project="${TEST_PROJECT_ID}", location="${TEST_LOCATION}"`);

  await withSettingsModal(page, async () => {
    // Expand Vertex AI section
    await expandVertexAISection(page);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    // Set test values
    const setProject = await setInputByPlaceholder(page, "your-gcp-project-id", TEST_PROJECT_ID);
    const setLocation = await setInputByPlaceholder(page, "us-central1", TEST_LOCATION);
    record("Set project ID", setProject ? "PASS" : "FAIL", setProject ? TEST_PROJECT_ID : "Failed");
    record("Set location", setLocation ? "PASS" : "FAIL", setLocation ? TEST_LOCATION : "Failed");

    // Verify values persisted
    const inputs = await getInputValues(page);
    const projectInput = inputs.find((i) => i.placeholder === "your-gcp-project-id");
    record(
      "Project ID persisted",
      projectInput?.value === TEST_PROJECT_ID ? "PASS" : "FAIL",
      `Got "${projectInput?.value}"`,
    );
  });
}

/**
 * Ensure user level is set to Pro (for per-beat test).
 */
async function ensureProMode(page: Page) {
  console.log("\n--- Ensuring Pro mode ---");

  await withSettingsModal(page, async () => {
    // The mode select has id="mode" on its trigger
    const modeSelect = await page.$("#mode");
    if (modeSelect) {
      await modeSelect.click({ force: true });
      await page.waitForTimeout(300);
      // Select Pro option – text is "Advanced" (en) or "\u4e0a\u7d1a" (ja)
      const proOption = page.locator('[role="option"]').filter({ hasText: /Advanced|\u4e0a\u7d1a/ });
      const count = await proOption.count();
      if (count > 0) {
        await proOption.first().click({ force: true });
        await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
        record("Set Pro mode", "PASS", "Selected Pro user level");
      } else {
        await page.keyboard.press("Escape");
        record("Set Pro mode", "WARN", "Pro option not found in dropdown");
      }
    } else {
      record("Set Pro mode", "WARN", "Mode select (#mode) not found");
    }
  });
}

// ==========================================
// Phase 2: Blank defaults (Settings blank)
// ==========================================

/**
 * Test 2a: Image Params - Blank defaults cycle.
 *   non-Google → hidden, switch Google → toggle visible + default OFF →
 *   toggle ON → stays ON → empty fields → toggle OFF → fields removed
 */
async function testImageParamsBlankDefaults(page: Page) {
  console.log("\n=== 2a. Image Params - Blank Defaults ===");

  // Navigate to style tab
  if (!(await navigateToStyleTab(page))) {
    record("Style tab", "FAIL", "Could not find Style tab");
    return;
  }

  // Scroll to image params section
  const scrolled = await scrollToImageParams(page);
  record("Scroll to Image Params", scrolled ? "PASS" : "FAIL", scrolled ? "Found" : "Not found");
  if (!scrolled) return;

  const imgProvIdx = await findImageProviderIndex(page);
  if (imgProvIdx < 0) {
    record("Image provider combobox", "FAIL", "Not found");
    return;
  }

  const comboTexts = await getComboboxTexts(page);
  const currentProvider = comboTexts[imgProvIdx] || "";

  // Step 1: Non-Google → Vertex AI hidden
  if (currentProvider !== "Google") {
    const switches = await getSwitchStates(page);
    const hasVertexToggle = switches.some((s) => s.label.includes("Vertex AI"));
    record(
      "Img: Vertex AI hidden (non-Google)",
      !hasVertexToggle ? "PASS" : "FAIL",
      `Provider="${currentProvider}", toggle=${hasVertexToggle}`,
    );
  }

  // Step 2: Switch to Google
  await clickComboboxByIndex(page, imgProvIdx);
  const selectedGoogle = await selectOption(page, "Google");
  record("Img: Switch to Google", selectedGoogle ? "PASS" : "FAIL", selectedGoogle ? "Selected" : "Failed");
  if (!selectedGoogle) return;

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await scrollToImageParams(page);

  // Step 3: Toggle visible + default OFF
  const switchesAfter = await getSwitchStates(page);
  const vertexToggle = switchesAfter.find((s) => s.label.includes("Vertex AI"));
  record("Img: Vertex AI toggle visible", vertexToggle ? "PASS" : "FAIL", vertexToggle ? "Found" : "Not found");
  if (!vertexToggle) return;

  record("Img: Toggle default OFF", !vertexToggle.checked ? "PASS" : "WARN", `checked=${vertexToggle.checked}`);

  // Step 4: Toggle ON with blank Settings → fields should be visible but empty
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const switchAfterOn = (await getSwitchStates(page)).find((s) => s.label.includes("Vertex AI"));
  record(
    "Img: Blank toggle stays ON",
    switchAfterOn?.checked ? "PASS" : "FAIL",
    switchAfterOn ? `checked=${switchAfterOn.checked}` : "Switch not found",
  );

  const inputsBlank = await getInputValues(page);
  const projectBlank = inputsBlank.find((i) => i.placeholder === "your-gcp-project-id");
  record(
    "Img: Blank defaults \u2192 empty fields visible",
    projectBlank !== undefined ? "PASS" : "FAIL",
    projectBlank ? `value="${projectBlank.value}"` : "Field not found",
  );

  // Step 5: Toggle OFF → fields removed
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsAfterOff = await getInputValues(page);
  const projectGone = !inputsAfterOff.some((i) => i.placeholder === "your-gcp-project-id");
  record(
    "Img: Toggle OFF \u2192 fields removed",
    projectGone ? "PASS" : "FAIL",
    projectGone ? "Removed" : "Still present",
  );
}

/**
 * Test 3a: Movie Params - Blank defaults cycle (same depth as Image Params).
 *   non-Google → hidden, switch Google → toggle visible + default OFF →
 *   toggle ON → stays ON → empty fields → toggle OFF → fields removed
 */
async function testMovieParamsBlankDefaults(page: Page) {
  console.log("\n=== 3a. Movie Params - Blank Defaults ===");

  // Scroll to movie params section
  const scrolled = await scrollToMovieParams(page);
  record("Scroll to Movie Params", scrolled ? "PASS" : "FAIL", scrolled ? "Found" : "Not found");
  if (!scrolled) return;

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const movieProvIdx = await findMovieProviderIndex(page);
  if (movieProvIdx < 0) {
    record("Movie provider combobox", "WARN", "Not found");
    return;
  }

  const comboTexts = await getComboboxTexts(page);
  const currentProvider = comboTexts[movieProvIdx] || "";

  // Step 1: Non-Google → Vertex AI hidden in movie section
  // Image section has Google selected but toggle OFF (no fields visible),
  // so image Vertex AI toggle is visible (unchecked). Movie should not have one.
  if (currentProvider !== "Google") {
    // Count toggles: only image's toggle should exist (1 total)
    const toggleCount = await countVertexAIToggles(page);
    record(
      "Movie: Vertex AI hidden (non-Google)",
      toggleCount <= 1 ? "PASS" : "FAIL",
      `Provider="${currentProvider}", total Vertex AI toggles=${toggleCount}`,
    );
  }

  // Step 2: Switch to Google
  if (currentProvider !== "Google") {
    await clickComboboxByIndex(page, movieProvIdx);
    const selected = await selectOption(page, "Google");
    record("Movie: Switch to Google", selected ? "PASS" : "FAIL", selected ? "Selected" : "Failed");
    if (!selected) return;
  } else {
    record("Movie: Provider already Google", "PASS", "No switch needed");
  }

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await scrollToMovieParams(page);

  // Step 3: Toggle visible + default OFF
  const switchesAfter = await getSwitchStates(page);
  const vertexSwitches = switchesAfter.filter((s) => s.label.includes("Vertex AI"));
  // Image section also shows toggle (unchecked), so expect >= 2
  record(
    "Movie: Vertex AI toggle visible",
    vertexSwitches.length >= 2 ? "PASS" : "WARN",
    `${vertexSwitches.length} Vertex AI toggle(s) total`,
  );

  // The movie toggle is the 2nd one (after image)
  const movieToggleNth = vertexSwitches.length >= 2 ? 2 : 1;
  const movieVertexToggle = vertexSwitches.length >= 2 ? vertexSwitches[1] : vertexSwitches[0];

  record(
    "Movie: Toggle default OFF",
    movieVertexToggle && !movieVertexToggle.checked ? "PASS" : "WARN",
    movieVertexToggle ? `checked=${movieVertexToggle.checked}` : "Not found",
  );

  // Step 4: Toggle ON with blank Settings → stays ON → empty fields
  const toggledOn = await clickNthVertexAISwitch(page, movieToggleNth);
  record("Movie: Toggle ON (blank)", toggledOn ? "PASS" : "FAIL", toggledOn ? "Clicked" : "Could not click");
  if (!toggledOn) return;

  // Verify toggle stays ON
  const switchAfterOn = (await getSwitchStates(page)).filter((s) => s.label.includes("Vertex AI"));
  const movieSwitchAfterOn = switchAfterOn.length >= 2 ? switchAfterOn[1] : switchAfterOn[0];
  record(
    "Movie: Blank toggle stays ON",
    movieSwitchAfterOn?.checked ? "PASS" : "FAIL",
    movieSwitchAfterOn ? `checked=${movieSwitchAfterOn.checked}` : "Switch not found",
  );

  // Verify empty fields visible
  // Image toggle is OFF so image fields are hidden. Only movie fields should appear.
  const inputsBlank = await getInputValues(page);
  const projectFields = inputsBlank.filter((i) => i.placeholder === "your-gcp-project-id");
  const hasEmptyProject = projectFields.some((f) => f.value === "");
  record(
    "Movie: Blank defaults \u2192 empty fields visible",
    hasEmptyProject ? "PASS" : "FAIL",
    `${projectFields.length} project field(s), empty=${hasEmptyProject}`,
  );

  // Step 5: Toggle OFF → fields removed
  await clickNthVertexAISwitch(page, movieToggleNth);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsAfterOff = await getInputValues(page);
  const projectAfterOff = inputsAfterOff.filter((i) => i.placeholder === "your-gcp-project-id");
  // All project fields from movie should be gone (image toggle is also OFF)
  record(
    "Movie: Toggle OFF \u2192 fields removed",
    projectAfterOff.length === 0 ? "PASS" : "FAIL",
    `${projectAfterOff.length} project field(s) remaining`,
  );
}

// ==========================================
// Phase 3: Prefill (Settings values set)
// ==========================================

/**
 * Test 2b: Image Params - Prefill cycle (Settings already set with values).
 *   toggle ON → pre-filled → toggle OFF → fields removed → toggle ON (leave ON for JSON)
 */
async function testImageParamsPrefill(page: Page) {
  console.log("\n=== 2b. Image Params - Prefill from Settings ===");

  // Navigate to style tab
  if (!(await navigateToStyleTab(page))) {
    record("Style tab", "FAIL", "Could not find Style tab");
    return;
  }

  await scrollToImageParams(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Toggle ON → should be pre-filled from Settings
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsFilled = await getInputValues(page);
  const projectFilled = inputsFilled.find((i) => i.placeholder === "your-gcp-project-id");
  const locationFilled = inputsFilled.find((i) => i.placeholder === "us-central1");

  record(
    "Img: Pre-filled project ID",
    projectFilled?.value === TEST_PROJECT_ID ? "PASS" : "WARN",
    `Expected "${TEST_PROJECT_ID}", got "${projectFilled?.value || "(not found)"}"`,
  );
  record(
    "Img: Pre-filled location",
    locationFilled?.value === TEST_LOCATION ? "PASS" : "WARN",
    `Expected "${TEST_LOCATION}", got "${locationFilled?.value || "(not found)"}"`,
  );

  // Toggle OFF → fields removed
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsAfterOff = await getInputValues(page);
  const projectGone = !inputsAfterOff.some(
    (i) => i.placeholder === "your-gcp-project-id" && i.value === TEST_PROJECT_ID,
  );
  record(
    "Img: Toggle OFF \u2192 fields removed",
    projectGone ? "PASS" : "FAIL",
    projectGone ? "Removed" : "Still present",
  );

  // Toggle back ON for JSON verification (leave ON)
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  record("Img: Toggle ON for JSON test", "PASS", "Left ON for subsequent tests");
}

/**
 * Test 3b: Movie Params - Prefill cycle (Settings already set with values).
 *   toggle ON → pre-filled → toggle OFF → fields removed → toggle ON (leave ON for JSON)
 */
async function testMovieParamsPrefill(page: Page) {
  console.log("\n=== 3b. Movie Params - Prefill from Settings ===");

  // Scroll to movie params section
  const scrolled = await scrollToMovieParams(page);
  record("Scroll to Movie Params", scrolled ? "PASS" : "FAIL", scrolled ? "Found" : "Not found");
  if (!scrolled) return;

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // At this point: image toggle is ON (from 2b), movie toggle is OFF.
  // Movie toggle is the 2nd Vertex AI switch.
  const switches = await getSwitchStates(page);
  const vertexSwitches = switches.filter((s) => s.label.includes("Vertex AI"));
  const movieToggleNth = vertexSwitches.length >= 2 ? 2 : 1;

  // Toggle ON → should be pre-filled from Settings
  const toggledOn = await clickNthVertexAISwitch(page, movieToggleNth);
  record("Movie: Toggle ON (prefill)", toggledOn ? "PASS" : "FAIL", toggledOn ? "Clicked" : "Could not click");
  if (!toggledOn) return;

  const inputsFilled = await getInputValues(page);
  const movieProjectFields = inputsFilled.filter((i) => i.placeholder === "your-gcp-project-id");
  const hasMovieProject = movieProjectFields.some((f) => f.value === TEST_PROJECT_ID);
  record(
    "Movie: Pre-filled project ID",
    hasMovieProject ? "PASS" : "WARN",
    hasMovieProject ? `Found "${TEST_PROJECT_ID}"` : `Values: ${movieProjectFields.map((f) => f.value).join(", ")}`,
  );

  const movieLocationFields = inputsFilled.filter((i) => i.placeholder === "us-central1");
  const hasMovieLocation = movieLocationFields.some((f) => f.value === TEST_LOCATION);
  record(
    "Movie: Pre-filled location",
    hasMovieLocation ? "PASS" : "WARN",
    hasMovieLocation ? `Found "${TEST_LOCATION}"` : `Values: ${movieLocationFields.map((f) => f.value).join(", ")}`,
  );

  // Toggle OFF → fields removed
  await clickNthVertexAISwitch(page, movieToggleNth);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsAfterOff = await getInputValues(page);
  const movieProjectAfterOff = inputsAfterOff.filter((i) => i.placeholder === "your-gcp-project-id");
  // Should be only 1 project field left (from image params)
  const movieFieldRemoved = !movieProjectAfterOff.some((f, idx) => idx > 0 && f.value === TEST_PROJECT_ID);
  record(
    "Movie: Toggle OFF \u2192 fields removed",
    movieFieldRemoved ? "PASS" : "FAIL",
    movieFieldRemoved ? "Movie Vertex AI fields removed" : "Fields still present",
  );

  // Toggle back ON for JSON verification
  await clickNthVertexAISwitch(page, movieToggleNth);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  record("Movie: Toggle ON for JSON test", "PASS", "Left ON for subsequent tests");
}

// ==========================================
// Phase 4: Per-beat (blank + prefill)
// ==========================================

/**
 * Test 4: Per-beat Vertex AI settings (requires Pro mode, imagePrompt beat).
 *
 * Per-beat imageParams are in the Media tab's beat editor, under
 * "Advanced Beat Settings" / "\u30d3\u30fc\u30c8\u306e\u8a73\u7d30\u8a2d\u5b9a" collapsible.
 *
 * Tests both blank defaults and prefill:
 *   Phase A: Clear Settings → toggle ON → empty fields → toggle OFF
 *   Phase B: Set Settings → toggle ON → pre-filled → toggle OFF
 */
async function testPerBeatVertexAI(page: Page) {
  console.log("\n=== 4. Per-beat Vertex AI Settings ===");

  // Switch to Media tab (where BeatEditor with Advanced Settings lives) using data-testid
  const mediaTab = await page.$('[data-testid="script-editor-tab-media"]');
  if (!mediaTab) {
    record("Per-beat: Switch to Media tab", "WARN", "Media tab not found (data-testid)");
    return;
  }
  await mediaTab.click();
  await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
  record("Per-beat: Switch to Media tab", "PASS", "Clicked via data-testid");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Find and expand "Advanced Beat Settings" collapsible
  const expanded = await page.evaluate(() => {
    const headings = document.querySelectorAll("h4");
    for (const h4 of headings) {
      const text = h4.textContent?.trim() || "";
      if (text.includes("Advanced Beat Settings") || text.includes("\u30d3\u30fc\u30c8\u306e\u8a73\u7d30\u8a2d\u5b9a")) {
        // Click the collapsible trigger (parent div with cursor-pointer)
        const trigger = h4.closest("[class*='cursor-pointer']") || h4.parentElement;
        if (trigger) {
          (trigger as HTMLElement).click();
          return true;
        }
      }
    }
    return false;
  });

  if (!expanded) {
    record("Per-beat: Advanced Settings", "WARN", "Collapsible not found \u2013 beat may not be imagePrompt type");
    await navigateToStyleTab(page);
    return;
  }
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  record("Per-beat: Advanced Settings expanded", "PASS", "Found and expanded");

  // Find and enable the custom imageParams checkbox
  const checkboxClicked = await page.evaluate(() => {
    const checkboxes = document.querySelectorAll('[role="checkbox"]');
    for (const cb of checkboxes) {
      const label = cb.closest("div")?.querySelector("label")?.textContent || "";
      if (label.includes("Override") || label.includes("\u753b\u50cf\u751f\u6210") || label.includes("\u3053\u306e\u30d3\u30fc\u30c8")) {
        if (cb.getAttribute("data-state") !== "checked") {
          (cb as HTMLElement).click();
        }
        return true;
      }
    }
    return false;
  });

  if (!checkboxClicked) {
    record("Per-beat: Custom imageParams checkbox", "WARN", "Checkbox not found");
    await navigateToStyleTab(page);
    return;
  }
  await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
  record("Per-beat: Enable custom imageParams", "PASS", "Checkbox enabled");

  // Scroll down to make the per-beat ImageParams visible
  await page.evaluate(() => {
    const scrollArea = document.querySelector('[class*="overflow-y-auto"]');
    if (scrollArea) scrollArea.scrollTop = scrollArea.scrollHeight;
  });
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Find the provider combobox near the custom imageParams checkbox
  const perBeatProviderIdx = await page.evaluate(() => {
    const checkboxes = document.querySelectorAll('[role="checkbox"]');
    for (const cb of checkboxes) {
      const label = cb.closest("div")?.querySelector("label")?.textContent || "";
      if (label.includes("Override") || label.includes("\u753b\u50cf\u751f\u6210") || label.includes("\u3053\u306e\u30d3\u30fc\u30c8")) {
        const checkboxRow = cb.closest(".flex.items-center.gap-2");
        const beatStyleRoot = checkboxRow?.parentElement;
        if (!beatStyleRoot) continue;
        const combo = beatStyleRoot.querySelector('[role="combobox"]');
        if (combo) {
          const allCombos = document.querySelectorAll('[role="combobox"]');
          for (let i = 0; i < allCombos.length; i++) {
            if (allCombos[i] === combo) return i;
          }
        }
      }
    }
    return -1;
  });

  if (perBeatProviderIdx < 0) {
    record("Per-beat: Provider combobox", "WARN", "Not found near custom imageParams checkbox");
    await navigateToStyleTab(page);
    return;
  }

  // Switch to Google
  await clickComboboxByIndex(page, perBeatProviderIdx);
  const beatGoogleSelected = await selectOption(page, "Google");

  if (!beatGoogleSelected) {
    record("Per-beat: Switch to Google", "WARN", "Could not select Google");
    await navigateToStyleTab(page);
    return;
  }
  record("Per-beat: Switch to Google", "PASS", "Selected Google for per-beat");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Verify Vertex AI toggle visible
  const toggleCount = await countVertexAIToggles(page);
  record(
    "Per-beat: Vertex AI toggle visible",
    toggleCount >= 1 ? "PASS" : "WARN",
    `${toggleCount} Vertex AI toggle(s) on Media tab (expected \u22651)`,
  );

  if (toggleCount < 1) {
    await cleanupPerBeat(page);
    return;
  }

  // ---- Phase A: Blank defaults ----
  console.log("  --- Per-beat Phase A: Blank defaults ---");

  // Clear Settings via modal (so toggle ON gets blank values)
  await withSettingsModal(page, async () => {
    await expandVertexAISection(page);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
    await clearInputByPlaceholder(page, "your-gcp-project-id");
    await clearInputByPlaceholder(page, "us-central1");
    record("Per-beat: Cleared Settings for blank test", "PASS", "Cleared");
  });

  // Scroll back to per-beat area after modal close
  await page.evaluate(() => {
    const scrollArea = document.querySelector('[class*="overflow-y-auto"]');
    if (scrollArea) scrollArea.scrollTop = scrollArea.scrollHeight;
  });
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Toggle ON → blank fields
  const toggledOnBlank = await clickNthVertexAISwitch(page, 1);
  record("Per-beat: Blank toggle ON", toggledOnBlank ? "PASS" : "FAIL", toggledOnBlank ? "Clicked" : "Failed");

  if (toggledOnBlank) {
    const switchAfterBlankOn = (await getSwitchStates(page)).find((s) => s.label.includes("Vertex AI"));
    record(
      "Per-beat: Blank toggle stays ON",
      switchAfterBlankOn?.checked ? "PASS" : "FAIL",
      switchAfterBlankOn ? `checked=${switchAfterBlankOn.checked}` : "Switch not found",
    );

    const inputsBlank = await getInputValues(page);
    const projectBlank = inputsBlank.find((i) => i.placeholder === "your-gcp-project-id");
    record(
      "Per-beat: Blank \u2192 empty fields",
      projectBlank !== undefined ? "PASS" : "FAIL",
      projectBlank ? `value="${projectBlank.value}"` : "Field not found",
    );

    // Toggle OFF
    await clickNthVertexAISwitch(page, 1);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    const switchAfterBlankOff = (await getSwitchStates(page)).find((s) => s.label.includes("Vertex AI"));
    record(
      "Per-beat: Blank toggle OFF",
      switchAfterBlankOff && !switchAfterBlankOff.checked ? "PASS" : "WARN",
      switchAfterBlankOff ? `checked=${switchAfterBlankOff.checked}` : "Switch not found",
    );
  }

  // ---- Phase B: Prefill from Settings ----
  console.log("  --- Per-beat Phase B: Prefill from Settings ---");

  // Set Settings values via modal
  await withSettingsModal(page, async () => {
    await expandVertexAISection(page);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
    await setInputByPlaceholder(page, "your-gcp-project-id", TEST_PROJECT_ID);
    await setInputByPlaceholder(page, "us-central1", TEST_LOCATION);
    record("Per-beat: Set Settings for prefill test", "PASS", `project="${TEST_PROJECT_ID}"`);
  });

  // Scroll back to per-beat area after modal close
  await page.evaluate(() => {
    const scrollArea = document.querySelector('[class*="overflow-y-auto"]');
    if (scrollArea) scrollArea.scrollTop = scrollArea.scrollHeight;
  });
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Toggle ON → pre-filled
  const toggledOnPrefill = await clickNthVertexAISwitch(page, 1);
  record("Per-beat: Prefill toggle ON", toggledOnPrefill ? "PASS" : "FAIL", toggledOnPrefill ? "Clicked" : "Failed");

  if (toggledOnPrefill) {
    const inputs = await getInputValues(page);
    const beatProjectFields = inputs.filter((i) => i.placeholder === "your-gcp-project-id");
    const hasBeatProject = beatProjectFields.some((f) => f.value === TEST_PROJECT_ID);
    record(
      "Per-beat: Pre-filled project ID",
      hasBeatProject ? "PASS" : "WARN",
      hasBeatProject
        ? `Found "${TEST_PROJECT_ID}"`
        : `Values: ${beatProjectFields.map((f) => f.value).join(", ")}`,
    );

    const beatLocationFields = inputs.filter((i) => i.placeholder === "us-central1");
    const hasBeatLocation = beatLocationFields.some((f) => f.value === TEST_LOCATION);
    record(
      "Per-beat: Pre-filled location",
      hasBeatLocation ? "PASS" : "WARN",
      hasBeatLocation
        ? `Found "${TEST_LOCATION}"`
        : `Values: ${beatLocationFields.map((f) => f.value).join(", ")}`,
    );

    // Toggle OFF
    await clickNthVertexAISwitch(page, 1);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    const switchAfterPrefillOff = (await getSwitchStates(page)).find((s) => s.label.includes("Vertex AI"));
    record(
      "Per-beat: Prefill toggle OFF",
      switchAfterPrefillOff && !switchAfterPrefillOff.checked ? "PASS" : "WARN",
      switchAfterPrefillOff ? `checked=${switchAfterPrefillOff.checked}` : "Switch not found",
    );
  }

  // Cleanup
  await cleanupPerBeat(page);
}

/** Disable custom imageParams checkbox and return to Style tab */
async function cleanupPerBeat(page: Page) {
  await page.evaluate(() => {
    const checkboxes = document.querySelectorAll('[role="checkbox"]');
    for (const cb of checkboxes) {
      const label = cb.closest("div")?.querySelector("label")?.textContent || "";
      if (
        (label.includes("Override") || label.includes("\u753b\u50cf\u751f\u6210") || label.includes("\u3053\u306e\u30d3\u30fc\u30c8")) &&
        cb.getAttribute("data-state") === "checked"
      ) {
        (cb as HTMLElement).click();
        return;
      }
    }
  });
  await new Promise((r) => setTimeout(r, CONFIG.ACTION_DELAY_MS));

  // Return to Style tab for subsequent tests
  await navigateToStyleTab(page);
}

// ==========================================
// Phase 5: Integration tests
// ==========================================

/**
 * Test 5: JSON reflection (UI \u2192 JSON).
 */
async function testJsonReflection(page: Page) {
  console.log("\n=== 5. JSON Editor - UI \u2192 JSON ===");

  // Switch to JSON tab
  const jsonClicked = await clickTabByText(page, "JSON");
  record("Switch to JSON tab", jsonClicked ? "PASS" : "FAIL", jsonClicked ? "Clicked" : "Not found");
  if (!jsonClicked) return;

  await page.waitForTimeout(CONFIG.EDITOR_LOAD_DELAY_MS);

  const json = await readEditorJson(page);
  if (!json) {
    record("Read JSON", "FAIL", "Could not read/parse editor content");
    return;
  }
  record("Read JSON", "PASS", "Successfully parsed");

  // Check imageParams
  const presentationStyle = json.presentationStyle as Record<string, unknown> | undefined;
  const imageParams = (presentationStyle?.imageParams || json.imageParams) as Record<string, unknown> | undefined;

  record(
    "JSON: imageParams.provider",
    imageParams?.provider === "google" ? "PASS" : "FAIL",
    `provider="${imageParams?.provider}"`,
  );
  record(
    "JSON: imageParams.vertexai_project",
    imageParams?.vertexai_project === TEST_PROJECT_ID ? "PASS" : "WARN",
    `vertexai_project="${imageParams?.vertexai_project}"`,
  );
  record(
    "JSON: imageParams.vertexai_location",
    imageParams?.vertexai_location === TEST_LOCATION ? "PASS" : "WARN",
    `vertexai_location="${imageParams?.vertexai_location}"`,
  );

  // Check movieParams
  const movieParams = (presentationStyle?.movieParams || json.movieParams) as Record<string, unknown> | undefined;
  record(
    "JSON: movieParams.provider",
    movieParams?.provider === "google" ? "PASS" : "WARN",
    `provider="${movieParams?.provider}"`,
  );
  record(
    "JSON: movieParams.vertexai_project",
    movieParams?.vertexai_project === TEST_PROJECT_ID ? "PASS" : "WARN",
    `vertexai_project="${movieParams?.vertexai_project}"`,
  );
  record(
    "JSON: movieParams.vertexai_location",
    movieParams?.vertexai_location === TEST_LOCATION ? "PASS" : "WARN",
    `vertexai_location="${movieParams?.vertexai_location}"`,
  );
}

/**
 * Test 6: JSON \u2192 UI reflection.
 */
async function testJsonToUI(page: Page) {
  console.log("\n=== 6. JSON \u2192 UI Reflection ===");

  // We should be on the JSON tab from the previous test.
  const json = await readEditorJson(page);
  if (!json) {
    record("Read JSON for edit", "FAIL", "Could not read editor content");
    return;
  }

  // Modify imageParams via JSON
  const imageParams = (json.imageParams || {}) as Record<string, unknown>;
  imageParams.provider = "google";
  imageParams.vertexai_project = JSON_EDIT_PROJECT_ID;
  imageParams.vertexai_location = JSON_EDIT_LOCATION;
  json.imageParams = imageParams;

  // Write modified JSON back
  const written = await writeEditorJson(page, json);
  record("Write modified JSON", written ? "PASS" : "FAIL", written ? "Written" : "Failed");
  if (!written) return;

  // Switch to Style tab
  const styleClicked = await navigateToStyleTab(page);
  record("Switch to Style tab", styleClicked ? "PASS" : "FAIL", styleClicked ? "Clicked" : "Not found");
  if (!styleClicked) return;

  await scrollToImageParams(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Verify provider is Google
  const imgProvIdx = await findImageProviderIndex(page);
  const comboTexts = await getComboboxTexts(page);
  const providerText = imgProvIdx >= 0 ? comboTexts[imgProvIdx] : "";
  record("JSON\u2192UI: Provider is Google", providerText === "Google" ? "PASS" : "FAIL", `Provider="${providerText}"`);

  // Verify Vertex AI toggle is ON
  const switches = await getSwitchStates(page);
  const vertexToggle = switches.find((s) => s.label.includes("Vertex AI"));
  record(
    "JSON\u2192UI: Vertex AI toggle ON",
    vertexToggle?.checked ? "PASS" : "FAIL",
    vertexToggle ? `checked=${vertexToggle.checked}` : "Not found",
  );

  // Verify field values
  const inputs = await getInputValues(page);
  const projectField = inputs.find((i) => i.placeholder === "your-gcp-project-id");
  const locationField = inputs.find((i) => i.placeholder === "us-central1");

  record(
    "JSON\u2192UI: Project ID reflected",
    projectField?.value === JSON_EDIT_PROJECT_ID ? "PASS" : "FAIL",
    `Expected "${JSON_EDIT_PROJECT_ID}", got "${projectField?.value || "(not found)"}"`,
  );
  record(
    "JSON\u2192UI: Location reflected",
    locationField?.value === JSON_EDIT_LOCATION ? "PASS" : "FAIL",
    `Expected "${JSON_EDIT_LOCATION}", got "${locationField?.value || "(not found)"}"`,
  );
}

/**
 * Test 7: Provider switch hides toggle.
 */
async function testProviderSwitchHidesToggle(page: Page) {
  console.log("\n=== 7. Provider Switch Hides Toggle ===");

  const styleClicked = await navigateToStyleTab(page);
  if (!styleClicked) {
    record("Switch to Style tab", "FAIL", "Tab not found");
    return;
  }

  await scrollToImageParams(page);

  // Switch image provider to OpenAI
  const imgProvIdx = await findImageProviderIndex(page);
  if (imgProvIdx >= 0) {
    await clickComboboxByIndex(page, imgProvIdx);
    const selected = await selectOption(page, "OpenAI");
    record("Switch image to OpenAI", selected ? "PASS" : "FAIL", selected ? "Selected" : "Failed");
    if (!selected) return;
  }

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await scrollToImageParams(page);

  // Verify image Vertex AI toggle is gone
  const toggleCount = await countVertexAIToggles(page);
  record(
    "Img: Vertex AI hidden after OpenAI",
    toggleCount <= 1 ? "PASS" : "FAIL",
    `${toggleCount} Vertex AI toggle(s) remaining`,
  );

  // Switch movie provider away from Google (movie has Replicate, not OpenAI)
  await scrollToMovieParams(page);
  const movieProvIdx = await findMovieProviderIndex(page);
  if (movieProvIdx >= 0) {
    await clickComboboxByIndex(page, movieProvIdx);
    const selected = await selectOption(page, "Replicate");
    record("Switch movie to Replicate", selected ? "PASS" : "FAIL", selected ? "Selected" : "Failed");
  }

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Verify all Vertex AI toggles are gone
  const finalToggleCount = await countVertexAIToggles(page);
  record(
    "All Vertex AI toggles hidden",
    finalToggleCount === 0 ? "PASS" : "FAIL",
    `${finalToggleCount} Vertex AI toggle(s) remaining`,
  );
}

/**
 * Test 8: Console health.
 */
async function testConsoleHealth(monitor: ConsoleMonitor) {
  console.log("\n=== 8. Console Health ===");
  record("Console errors", monitor.errors.length === 0 ? "PASS" : "WARN", `${monitor.errors.length} error(s) total`);
  if (monitor.errors.length > 0) {
    console.log(`    Errors: ${monitor.errors.slice(0, 5).join("; ")}`);
  }
}

// --- Main ---

(async () => {
  console.log("========================================");
  console.log("  Vertex AI Support QA Test Suite");
  console.log(`  ${timestamp}`);
  console.log(`  Run ID: ${runId}`);
  console.log(`  Test values: project="${TEST_PROJECT_ID}", location="${TEST_LOCATION}"`);
  console.log("========================================\n");

  const resources: { browser: Browser | null } = { browser: null };
  let exitCode = 1;

  try {
    resources.browser = await connectCDP();
    const contexts = resources.browser.contexts();

    if (contexts.length === 0) {
      throw new Error("No browser contexts found");
    }

    const page = findAppPage(contexts);
    console.log(`App page: ${page.url()}`);

    // Start console monitoring
    const monitor = createConsoleMonitor(page);
    monitor.start();

    // Navigate to home first
    await page.goto(page.url().split("#")[0] + "#/");
    await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);

    // Dismiss any open modal/dialog overlay (e.g., onboarding modal)
    const overlay = await page.$('[data-state="open"][aria-hidden="true"]');
    if (overlay) {
      console.log("Dismissing open modal overlay...");
      await page.keyboard.press("Escape");
      await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
    }

    // ==========================================
    // Phase 1: Setup
    // ==========================================
    console.log("\n==========================================");
    console.log("  Phase 1: Setup");
    console.log("==========================================");

    // 1a. Settings – blank defaults
    await testSettingsBlankDefaults(page);

    // 1b. Ensure Pro mode
    await ensureProMode(page);

    // Create test project
    console.log("\n--- Creating test project ---");
    const newBtn = await page.$('[data-testid="create-new-button"]');
    if (newBtn) {
      await newBtn.click();
      await page.waitForTimeout(CONFIG.PROJECT_CREATE_DELAY_MS);
      const url = page.url();
      record("Test project created", url.includes("#/project/") ? "PASS" : "FAIL", `URL: ${url}`);

      // Set project title and description via JSON editor
      const jsonTabClicked = await clickTabByText(page, "JSON");
      if (jsonTabClicked) {
        await page.waitForTimeout(CONFIG.EDITOR_LOAD_DELAY_MS);
        const json = await readEditorJson(page);
        if (json) {
          json.title = TEST_PROJECT_TITLE;
          json.description = TEST_PROJECT_DESCRIPTION;
          const written = await writeEditorJson(page, json);
          record(
            "Set project title/description",
            written ? "PASS" : "FAIL",
            written ? `Title: "${TEST_PROJECT_TITLE}"` : "Failed to write JSON",
          );
        }
      }
    } else {
      const firstProject = await page.$('a[href*="project"]');
      if (firstProject) {
        await firstProject.click();
        await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
      }
    }

    // ==========================================
    // Phase 2: Blank defaults (Settings blank)
    // ==========================================
    console.log("\n==========================================");
    console.log("  Phase 2: Blank Defaults");
    console.log("==========================================");

    // 2a. Image Params – blank cycle
    await testImageParamsBlankDefaults(page);

    // 3a. Movie Params – blank cycle
    await testMovieParamsBlankDefaults(page);

    // ==========================================
    // Phase 3: Prefill (Settings set)
    // ==========================================
    console.log("\n==========================================");
    console.log("  Phase 3: Prefill from Settings");
    console.log("==========================================");

    // 1c. Settings – set values
    await testSettingsSetValues(page);

    // 2b. Image Params – prefill cycle
    await testImageParamsPrefill(page);

    // 3b. Movie Params – prefill cycle
    await testMovieParamsPrefill(page);

    // ==========================================
    // Phase 4: Per-beat (blank + prefill)
    // ==========================================
    console.log("\n==========================================");
    console.log("  Phase 4: Per-beat Vertex AI");
    console.log("==========================================");

    // 4. Per-beat Vertex AI
    await testPerBeatVertexAI(page);

    // ==========================================
    // Phase 5: Integration
    // ==========================================
    console.log("\n==========================================");
    console.log("  Phase 5: Integration");
    console.log("==========================================");

    // 5. JSON Reflection (UI → JSON)
    await testJsonReflection(page);

    // 6. JSON → UI Reflection
    await testJsonToUI(page);

    // 7. Provider Switch Hides Toggle
    await testProviderSwitchHidesToggle(page);

    // 8. Console Health
    await testConsoleHealth(monitor);

    monitor.stop();

    // Navigate back to home
    await page.goto(page.url().split("#")[0] + "#/");
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    // --- Summary ---
    console.log("\n========================================");
    console.log("  TEST SUMMARY");
    console.log("========================================");

    const pass = results.filter((r) => r.status === "PASS").length;
    const fail = results.filter((r) => r.status === "FAIL").length;
    const warn = results.filter((r) => r.status === "WARN").length;

    console.log(`  PASS: ${pass}`);
    console.log(`  FAIL: ${fail}`);
    console.log(`  WARN: ${warn}`);
    console.log(`  TOTAL: ${results.length}`);
    console.log("----------------------------------------");

    if (fail > 0) {
      console.log("\n  Failed tests:");
      results.filter((r) => r.status === "FAIL").forEach((r) => console.log(`    \u2717 ${r.name}: ${r.detail}`));
    }

    exitCode = fail === 0 ? 0 : 1;
    console.log("\n========================================");
  } catch (error) {
    console.error("\nTest suite failed:", error);
    exitCode = 1;
  } finally {
    if (resources.browser) {
      await resources.browser.close().catch(() => {});
    }
    process.exit(exitCode);
  }
})();
