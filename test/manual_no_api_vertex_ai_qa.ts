/**
 * Vertex AI Support QA Test Suite
 *
 * Manual test script to verify Vertex AI integration in the MulmoCast app.
 * Connects to a running Electron app via CDP and validates:
 *   1. Settings page: Vertex AI section – blank defaults, then set values
 *   2. Image Params: full toggle cycle (non-Google hidden → Google → ON blank → OFF → ON pre-fill)
 *   3. Movie Params: same full toggle cycle as Image Params
 *   4. Per-beat: custom imageParams with Vertex AI toggle (Pro mode)
 *   5. JSON Editor: UI → JSON reflection
 *   6. JSON → UI reflection
 *   7. Provider switch hides toggle
 *   8. Console health
 *
 * Usage:
 *   1. Start the app: yarn start
 *   2. Run: npx tsx test/manual_no_api_vertex_ai_qa.ts
 *
 * Environment variables:
 *   CDP_URL  - CDP endpoint (default: http://localhost:9222/)
 *   APP_URL  - App URL fragment to match (default: localhost:5175)
 */
import playwright, { Browser, BrowserContext, ConsoleMessage, Page } from "playwright-core";

const CONFIG = {
  CDP_RETRY_DELAY_MS: 1000,
  CDP_MAX_ATTEMPTS: 30,
  ACTION_DELAY_MS: 500,
  NAVIGATION_DELAY_MS: 1000,
  EDITOR_LOAD_DELAY_MS: 1500,
  SETTINGS_SAVE_DELAY_MS: 2000,
  PROJECT_CREATE_DELAY_MS: 3000,
} as const;

const timestamp = new Date().toISOString().replace(/T/, " ").replace(/\..+/, "");
const TEST_PROJECT_TITLE = `[QA] Vertex AI Test ${timestamp}`;
const TEST_PROJECT_DESCRIPTION = "Auto-generated by manual_no_api_vertex_ai_qa.ts – safe to delete";
const TEST_PROJECT_ID = `qa-project-${Date.now()}`;
const TEST_LOCATION = "asia-northeast1";
const JSON_EDIT_PROJECT_ID = `json-edit-${Date.now()}`;
const JSON_EDIT_LOCATION = "europe-west1";

interface TestResult {
  name: string;
  status: "PASS" | "FAIL" | "WARN";
  detail: string;
}

const results: TestResult[] = [];

function record(name: string, status: "PASS" | "FAIL" | "WARN", detail: string) {
  results.push({ name, status, detail });
  const icon = status === "PASS" ? "✓" : status === "FAIL" ? "✗" : "⚠";
  console.log(`  ${icon} [${status}] ${name}: ${detail}`);
}

// --- Infrastructure ---

async function connectCDP(): Promise<Browser> {
  const cdpUrl = process.env.CDP_URL || "http://localhost:9222/";
  let attempts = 0;

  while (attempts < CONFIG.CDP_MAX_ATTEMPTS) {
    try {
      const browser = await playwright.chromium.connectOverCDP(cdpUrl);
      console.log("✓ Connected to CDP");
      return browser;
    } catch (error: unknown) {
      attempts++;
      if (attempts === CONFIG.CDP_MAX_ATTEMPTS) {
        throw new Error(
          `Failed to connect after ${CONFIG.CDP_MAX_ATTEMPTS} attempts: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
      if (attempts === 1) {
        console.log(`Connecting to ${cdpUrl}...`);
      }
      await new Promise((resolve) => setTimeout(resolve, CONFIG.CDP_RETRY_DELAY_MS));
    }
  }
  throw new Error("Unreachable");
}

function findAppPage(contexts: BrowserContext[]): Page {
  const appUrl = process.env.APP_URL || "localhost:5175";
  for (const context of contexts) {
    const page = context.pages().find((p) => p.url().includes(appUrl));
    if (page) return page;
  }
  // fallback: try 5173
  for (const context of contexts) {
    const page = context.pages().find((p) => p.url().includes("localhost:5173"));
    if (page) return page;
  }
  throw new Error("Could not find application page");
}

// --- Console Monitoring ---

interface ConsoleMonitor {
  errors: string[];
  warnings: string[];
  start: () => void;
  stop: () => void;
  reset: () => void;
}

function createConsoleMonitor(page: Page): ConsoleMonitor {
  const monitor: ConsoleMonitor = {
    errors: [],
    warnings: [],
    start: () => {
      page.on("console", handler);
    },
    stop: () => {
      page.off("console", handler);
    },
    reset: () => {
      monitor.errors = [];
      monitor.warnings = [];
    },
  };

  const handler = (msg: ConsoleMessage) => {
    const text = msg.text();
    const type = msg.type();
    if (type === "error") {
      monitor.errors.push(text);
    }
    if (type === "warning") {
      monitor.warnings.push(text);
    }
  };

  return monitor;
}

// --- Helpers ---

const selectAllKey = process.platform === "darwin" ? "Meta+a" : "Control+a";
const copyKey = process.platform === "darwin" ? "Meta+c" : "Control+c";
const pasteKey = process.platform === "darwin" ? "Meta+v" : "Control+v";

async function clickTabByText(page: Page, tabText: string): Promise<boolean> {
  const tabs = await page.locator('[role="tab"]').all();
  for (const tab of tabs) {
    const text = await tab.textContent();
    if (text?.trim() === tabText) {
      await tab.click();
      await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
      return true;
    }
  }
  return false;
}

async function scrollToH4(page: Page, heading: string): Promise<boolean> {
  return page.evaluate((h) => {
    const h4s = document.querySelectorAll("h4");
    for (const el of h4s) {
      if (el.textContent?.trim() === h) {
        el.scrollIntoView({ behavior: "instant", block: "start" });
        return true;
      }
    }
    return false;
  }, heading);
}

async function getComboboxTexts(page: Page): Promise<string[]> {
  return page.evaluate(() => {
    const selects = document.querySelectorAll('[role="combobox"]');
    return Array.from(selects).map((s) => s.textContent?.trim() || "");
  });
}

/**
 * Find the global index of the first combobox inside the card that contains the given h4 heading.
 */
async function findComboboxIndexInSection(page: Page, heading: string): Promise<number> {
  return page.evaluate((h) => {
    const h4s = document.querySelectorAll("h4");
    for (const h4 of h4s) {
      if (h4.textContent?.trim() === h) {
        // Walk up to find the Card container
        const card = h4.closest(".p-4, [class*='card']") || h4.parentElement?.parentElement;
        if (!card) continue;
        // Find first combobox inside this card
        const combo = card.querySelector('[role="combobox"]');
        if (!combo) continue;
        // Find its global index
        const allCombos = document.querySelectorAll('[role="combobox"]');
        for (let i = 0; i < allCombos.length; i++) {
          if (allCombos[i] === combo) return i;
        }
      }
    }
    return -1;
  }, heading);
}

async function clickComboboxByIndex(page: Page, index: number): Promise<void> {
  await page.locator('[role="combobox"]').nth(index).click({ force: true });
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
}

async function selectOption(page: Page, optionText: string): Promise<boolean> {
  // Wait for dropdown to appear
  await page.waitForTimeout(300);
  const option = page.locator('[role="option"]').filter({ hasText: new RegExp(`^${optionText}$`) });
  const count = await option.count();
  if (count > 0) {
    await option.first().click({ force: true });
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
    return true;
  }
  // Close dropdown if option not found
  await page.keyboard.press("Escape");
  await page.waitForTimeout(300);
  return false;
}

async function getSwitchStates(page: Page): Promise<Array<{ label: string; checked: boolean }>> {
  return page.evaluate(() => {
    const switches = document.querySelectorAll('[role="switch"]');
    return Array.from(switches).map((s) => {
      const label = s.closest("div")?.querySelector("label")?.textContent || "";
      return { label, checked: s.getAttribute("data-state") === "checked" };
    });
  });
}

async function clickSwitchByLabel(page: Page, label: string): Promise<boolean> {
  const clicked = await page.evaluate((lbl) => {
    const switches = document.querySelectorAll('[role="switch"]');
    for (const sw of switches) {
      const parentLabel = sw.closest("div")?.querySelector("label")?.textContent || "";
      if (parentLabel.includes(lbl)) {
        (sw as HTMLElement).click();
        return true;
      }
    }
    return false;
  }, label);
  if (clicked) {
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  }
  return clicked;
}

/**
 * Click the nth Vertex AI switch (1-based index).
 */
async function clickNthVertexAISwitch(page: Page, nth: number): Promise<boolean> {
  const clicked = await page.evaluate((n) => {
    const switches = document.querySelectorAll('[role="switch"]');
    let count = 0;
    for (const sw of switches) {
      const label = sw.closest("div")?.querySelector("label")?.textContent || "";
      if (label.includes("Vertex AI")) {
        count++;
        if (count === n) {
          (sw as HTMLElement).click();
          return true;
        }
      }
    }
    return false;
  }, nth);
  if (clicked) {
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  }
  return clicked;
}

async function getInputValues(page: Page): Promise<Array<{ placeholder: string; value: string }>> {
  return page.evaluate(() => {
    const inputs = document.querySelectorAll("input[type='text'], input:not([type])");
    return Array.from(inputs).map((input) => ({
      placeholder: (input as HTMLInputElement).getAttribute("placeholder") || "",
      value: (input as HTMLInputElement).value || "",
    }));
  });
}

async function setInputByPlaceholder(page: Page, placeholder: string, value: string): Promise<boolean> {
  return page.evaluate(
    ({ ph, val }) => {
      const inputs = document.querySelectorAll("input");
      for (const input of inputs) {
        if (input.getAttribute("placeholder") === ph) {
          const setter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")?.set;
          if (setter) {
            setter.call(input, val);
            input.dispatchEvent(new Event("input", { bubbles: true }));
            return true;
          }
        }
      }
      return false;
    },
    { ph: placeholder, val: value },
  );
}

async function clearInputByPlaceholder(page: Page, placeholder: string): Promise<boolean> {
  return setInputByPlaceholder(page, placeholder, "");
}

async function readEditorJson(page: Page): Promise<Record<string, unknown> | null> {
  const viewLines = await page.$(".monaco-editor .view-lines");
  if (!viewLines) return null;
  await viewLines.click();
  await page.waitForTimeout(300);
  await page.keyboard.press(selectAllKey);
  await page.waitForTimeout(200);
  await page.keyboard.press(copyKey);
  await page.waitForTimeout(200);
  const text = await page.evaluate(() => navigator.clipboard.readText());
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

async function writeEditorJson(page: Page, json: Record<string, unknown>): Promise<boolean> {
  const viewLines = await page.$(".monaco-editor .view-lines");
  if (!viewLines) return false;
  await viewLines.click();
  await page.waitForTimeout(300);
  await page.keyboard.press(selectAllKey);
  await page.waitForTimeout(200);
  const newText = JSON.stringify(json, null, 2);
  await page.evaluate((t) => navigator.clipboard.writeText(t), newText);
  await page.waitForTimeout(200);
  await page.keyboard.press(pasteKey);
  await page.waitForTimeout(1000);
  return true;
}

/** Open settings modal, run callback, close modal */
async function withSettingsModal(page: Page, callback: () => Promise<void>): Promise<boolean> {
  const settingsBtn = await page.$('[data-testid="settings-button"]');
  if (!settingsBtn) {
    record("Settings button", "FAIL", "Settings button not found");
    return false;
  }
  await settingsBtn.click();
  await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);

  const langSelect = await page.$('[data-testid="language-select"]');
  if (!langSelect) {
    record("Settings modal opened", "FAIL", "Modal did not open");
    return false;
  }

  await callback();

  // Wait for debounced save, then close
  await page.waitForTimeout(CONFIG.SETTINGS_SAVE_DELAY_MS);
  await page.keyboard.press("Escape");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  return true;
}

/** Expand the Vertex AI collapsible in settings if not already expanded */
async function expandVertexAISection(page: Page): Promise<boolean> {
  return page.evaluate(() => {
    const buttons = document.querySelectorAll("button");
    for (const btn of buttons) {
      if (btn.textContent?.includes("Vertex AI")) {
        // Check if already expanded by looking at data-state
        const collapsible = btn.closest("[data-state]");
        if (collapsible?.getAttribute("data-state") === "open") return true;
        btn.click();
        return true;
      }
    }
    return false;
  });
}

async function navigateToStyleTab(page: Page): Promise<boolean> {
  return (await clickTabByText(page, "スタイル")) || (await clickTabByText(page, "Style"));
}

async function scrollToImageParams(page: Page): Promise<boolean> {
  return (await scrollToH4(page, "画像生成設定")) || (await scrollToH4(page, "Image Parameters"));
}

async function scrollToMovieParams(page: Page): Promise<boolean> {
  return (await scrollToH4(page, "動画生成設定")) || (await scrollToH4(page, "Movie Parameters"));
}

async function findImageProviderIndex(page: Page): Promise<number> {
  let idx = await findComboboxIndexInSection(page, "画像生成設定");
  if (idx < 0) idx = await findComboboxIndexInSection(page, "Image Parameters");
  return idx;
}

async function findMovieProviderIndex(page: Page): Promise<number> {
  let idx = await findComboboxIndexInSection(page, "動画生成設定");
  if (idx < 0) idx = await findComboboxIndexInSection(page, "Movie Parameters");
  return idx;
}

/** Count Vertex AI toggles currently visible */
async function countVertexAIToggles(page: Page): Promise<number> {
  const switches = await getSwitchStates(page);
  return switches.filter((s) => s.label.includes("Vertex AI")).length;
}

// --- Test Cases ---

/**
 * Test 1a: Settings – Verify Vertex AI section exists and fields are present.
 *          Clear any existing values (blank defaults).
 */
async function testSettingsBlankDefaults(page: Page) {
  console.log("\n=== 1a. Settings - Blank Vertex AI Defaults ===");

  await withSettingsModal(page, async () => {
    record("Settings modal opened", "PASS", "Found");

    // Check Vertex AI section exists
    const vertexAIExists = await page.evaluate(() => {
      const buttons = document.querySelectorAll("button");
      return Array.from(buttons).some((b) => b.textContent?.includes("Vertex AI"));
    });
    record("Vertex AI section exists", vertexAIExists ? "PASS" : "FAIL", vertexAIExists ? "Found" : "Not found");
    if (!vertexAIExists) return;

    // Expand Vertex AI section
    await expandVertexAISection(page);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    // Check input fields
    const inputs = await getInputValues(page);
    const projectInput = inputs.find((i) => i.placeholder === "your-gcp-project-id");
    const locationInput = inputs.find((i) => i.placeholder === "us-central1");

    record("Project ID field", projectInput ? "PASS" : "FAIL", projectInput ? "Found" : "Not found");
    record("Location field", locationInput ? "PASS" : "FAIL", locationInput ? "Found" : "Not found");

    // Clear values to test blank defaults
    await clearInputByPlaceholder(page, "your-gcp-project-id");
    await clearInputByPlaceholder(page, "us-central1");
    record("Cleared Vertex AI fields", "PASS", "Set project and location to blank");
  });
}

/**
 * Test 1b: Settings – Set Vertex AI project ID and location values.
 *          Also ensure user level is Pro (required for per-beat tests).
 */
async function testSettingsSetValues(page: Page) {
  console.log("\n=== 1b. Settings - Set Vertex AI Values ===");

  await withSettingsModal(page, async () => {
    // Expand Vertex AI section
    await expandVertexAISection(page);
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    // Set test values
    const setProject = await setInputByPlaceholder(page, "your-gcp-project-id", TEST_PROJECT_ID);
    const setLocation = await setInputByPlaceholder(page, "us-central1", TEST_LOCATION);
    record("Set project ID", setProject ? "PASS" : "FAIL", setProject ? TEST_PROJECT_ID : "Failed");
    record("Set location", setLocation ? "PASS" : "FAIL", setLocation ? TEST_LOCATION : "Failed");

    // Verify values persisted
    const inputs = await getInputValues(page);
    const projectInput = inputs.find((i) => i.placeholder === "your-gcp-project-id");
    record(
      "Project ID persisted",
      projectInput?.value === TEST_PROJECT_ID ? "PASS" : "FAIL",
      `Got "${projectInput?.value}"`,
    );
  });
}

/**
 * Ensure user level is set to Pro (for per-beat test).
 */
async function ensureProMode(page: Page) {
  console.log("\n--- Ensuring Pro mode ---");

  await withSettingsModal(page, async () => {
    // The mode select has id="mode" on its trigger
    const modeSelect = await page.$("#mode");
    if (modeSelect) {
      await modeSelect.click({ force: true });
      await page.waitForTimeout(300);
      // Select Pro option – text is "Advanced" (en) or "上級" (ja)
      const proOption = page.locator('[role="option"]').filter({ hasText: /Advanced|上級/ });
      const count = await proOption.count();
      if (count > 0) {
        await proOption.first().click({ force: true });
        await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
        record("Set Pro mode", "PASS", "Selected Pro user level");
      } else {
        await page.keyboard.press("Escape");
        record("Set Pro mode", "WARN", "Pro option not found in dropdown");
      }
    } else {
      record("Set Pro mode", "WARN", "Mode select (#mode) not found");
    }
  });
}

/**
 * Test 2: Image Params - Full Vertex AI toggle cycle.
 *   Phase A: Settings blank → toggle ON → fields empty
 *   Phase B: Settings set → toggle OFF → toggle ON → pre-filled
 */
async function testImageParamsVertexAI(page: Page) {
  console.log("\n=== 2. Image Params - Vertex AI Toggle ===");

  // Navigate to style tab
  if (!(await navigateToStyleTab(page))) {
    record("Style tab", "FAIL", "Could not find Style tab");
    return;
  }

  // Scroll to image params section
  const scrolled = await scrollToImageParams(page);
  record("Scroll to Image Params", scrolled ? "PASS" : "FAIL", scrolled ? "Found" : "Not found");
  if (!scrolled) return;

  const imgProvIdx = await findImageProviderIndex(page);
  if (imgProvIdx < 0) {
    record("Image provider combobox", "FAIL", "Not found");
    return;
  }

  const comboTexts = await getComboboxTexts(page);
  const currentProvider = comboTexts[imgProvIdx] || "";

  // Step 1: Non-Google → Vertex AI hidden
  if (currentProvider !== "Google") {
    const switches = await getSwitchStates(page);
    const hasVertexToggle = switches.some((s) => s.label.includes("Vertex AI"));
    record(
      "Img: Vertex AI hidden (non-Google)",
      !hasVertexToggle ? "PASS" : "FAIL",
      `Provider="${currentProvider}", toggle=${hasVertexToggle}`,
    );
  }

  // Step 2: Switch to Google
  await clickComboboxByIndex(page, imgProvIdx);
  const selectedGoogle = await selectOption(page, "Google");
  record("Img: Switch to Google", selectedGoogle ? "PASS" : "FAIL", selectedGoogle ? "Selected" : "Failed");
  if (!selectedGoogle) return;

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await scrollToImageParams(page);

  // Step 3: Toggle visible + default OFF
  const switchesAfter = await getSwitchStates(page);
  const vertexToggle = switchesAfter.find((s) => s.label.includes("Vertex AI"));
  record("Img: Vertex AI toggle visible", vertexToggle ? "PASS" : "FAIL", vertexToggle ? "Found" : "Not found");
  if (!vertexToggle) return;

  record("Img: Toggle default OFF", !vertexToggle.checked ? "PASS" : "WARN", `checked=${vertexToggle.checked}`);

  // Step 4: Toggle ON with blank Settings → fields should be visible but empty
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // With the fix (undefined check instead of truthy check), toggle should stay ON
  // and show empty input fields that the user can fill in directly
  const switchAfterOn = (await getSwitchStates(page)).find((s) => s.label.includes("Vertex AI"));
  record(
    "Img: Blank toggle stays ON",
    switchAfterOn?.checked ? "PASS" : "FAIL",
    switchAfterOn ? `checked=${switchAfterOn.checked}` : "Switch not found",
  );

  const inputsBlank = await getInputValues(page);
  const projectBlank = inputsBlank.find((i) => i.placeholder === "your-gcp-project-id");
  record(
    "Img: Blank defaults → empty fields visible",
    projectBlank !== undefined ? "PASS" : "FAIL",
    projectBlank ? `value="${projectBlank.value}"` : "Field not found",
  );

  // Step 5: Toggle OFF → fields removed
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsAfterOff = await getInputValues(page);
  const projectGone = !inputsAfterOff.some(
    (i) => i.placeholder === "your-gcp-project-id" && i.value !== "",
  );
  record("Img: Toggle OFF → fields removed", projectGone ? "PASS" : "FAIL", projectGone ? "Removed" : "Still present");

  // --- Now set Settings values ---
  console.log("  ... Setting Vertex AI defaults in Settings ...");
  await testSettingsSetValues(page);

  // Return to Style tab and scroll to image params
  await navigateToStyleTab(page);
  await scrollToImageParams(page);

  // Step 6: Toggle ON with Settings values → pre-filled
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsFilled = await getInputValues(page);
  const projectFilled = inputsFilled.find((i) => i.placeholder === "your-gcp-project-id");
  const locationFilled = inputsFilled.find((i) => i.placeholder === "us-central1");

  record(
    "Img: Pre-filled project ID",
    projectFilled?.value === TEST_PROJECT_ID ? "PASS" : "WARN",
    `Expected "${TEST_PROJECT_ID}", got "${projectFilled?.value || "(not found)"}"`,
  );
  record(
    "Img: Pre-filled location",
    locationFilled?.value === TEST_LOCATION ? "PASS" : "WARN",
    `Expected "${TEST_LOCATION}", got "${locationFilled?.value || "(not found)"}"`,
  );

  // Step 7: Toggle OFF → fields removed again
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsFinalOff = await getInputValues(page);
  const projectFinalGone = !inputsFinalOff.some(
    (i) => i.placeholder === "your-gcp-project-id" && i.value === TEST_PROJECT_ID,
  );
  record(
    "Img: Toggle OFF again → fields removed",
    projectFinalGone ? "PASS" : "FAIL",
    projectFinalGone ? "Removed" : "Still present",
  );

  // Step 8: Toggle back ON for JSON verification (leave ON)
  await clickSwitchByLabel(page, "Vertex AI");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  record("Img: Toggle ON for JSON test", "PASS", "Left ON for subsequent tests");
}

/**
 * Test 3: Movie Params - Full Vertex AI toggle cycle (same depth as Image Params).
 */
async function testMovieParamsVertexAI(page: Page) {
  console.log("\n=== 3. Movie Params - Vertex AI Toggle ===");

  // Scroll to movie params section
  const scrolled = await scrollToMovieParams(page);
  record("Scroll to Movie Params", scrolled ? "PASS" : "FAIL", scrolled ? "Found" : "Not found");
  if (!scrolled) return;

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const movieProvIdx = await findMovieProviderIndex(page);
  if (movieProvIdx < 0) {
    record("Movie provider combobox", "WARN", "Not found");
    return;
  }

  const comboTexts = await getComboboxTexts(page);
  const currentProvider = comboTexts[movieProvIdx] || "";

  // Step 1: Non-Google → Vertex AI hidden in movie section
  // We need to count toggles. Image section already has one ON.
  // If movie is not Google, there should be only 1 Vertex AI toggle (from image).
  if (currentProvider !== "Google") {
    const toggleCount = await countVertexAIToggles(page);
    record(
      "Movie: Vertex AI hidden (non-Google)",
      toggleCount <= 1 ? "PASS" : "FAIL",
      `Provider="${currentProvider}", total Vertex AI toggles=${toggleCount}`,
    );
  }

  // Step 2: Switch to Google
  if (currentProvider !== "Google") {
    await clickComboboxByIndex(page, movieProvIdx);
    const selected = await selectOption(page, "Google");
    record("Movie: Switch to Google", selected ? "PASS" : "FAIL", selected ? "Selected" : "Failed");
    if (!selected) return;
  } else {
    record("Movie: Provider already Google", "PASS", "No switch needed");
  }

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await scrollToMovieParams(page);

  // Step 3: Vertex AI toggle visible
  const switchesAfter = await getSwitchStates(page);
  const vertexSwitches = switchesAfter.filter((s) => s.label.includes("Vertex AI"));
  // At least 2 (image + movie)
  record(
    "Movie: Vertex AI toggle visible",
    vertexSwitches.length >= 2 ? "PASS" : "WARN",
    `${vertexSwitches.length} Vertex AI toggle(s) total`,
  );

  // Find the movie Vertex AI toggle (2nd one)
  const movieVertexToggle = vertexSwitches.length >= 2 ? vertexSwitches[1] : null;

  // Step 4: Default OFF
  record(
    "Movie: Toggle default OFF",
    movieVertexToggle && !movieVertexToggle.checked ? "PASS" : "WARN",
    movieVertexToggle ? `checked=${movieVertexToggle.checked}` : "Not found",
  );

  // Step 5: Toggle ON → pre-filled from Settings
  const toggledOn = await clickNthVertexAISwitch(page, 2);
  record("Movie: Toggle ON", toggledOn ? "PASS" : "FAIL", toggledOn ? "Clicked" : "Could not click");
  if (!toggledOn) return;

  const inputsFilled = await getInputValues(page);
  const movieProjectFields = inputsFilled.filter((i) => i.placeholder === "your-gcp-project-id");
  const hasMovieProject = movieProjectFields.some((f) => f.value === TEST_PROJECT_ID);
  record(
    "Movie: Pre-filled project ID",
    hasMovieProject ? "PASS" : "WARN",
    hasMovieProject ? `Found "${TEST_PROJECT_ID}"` : `Values: ${movieProjectFields.map((f) => f.value).join(", ")}`,
  );

  const movieLocationFields = inputsFilled.filter((i) => i.placeholder === "us-central1");
  const hasMovieLocation = movieLocationFields.some((f) => f.value === TEST_LOCATION);
  record(
    "Movie: Pre-filled location",
    hasMovieLocation ? "PASS" : "WARN",
    hasMovieLocation ? `Found "${TEST_LOCATION}"` : `Values: ${movieLocationFields.map((f) => f.value).join(", ")}`,
  );

  // Step 6: Toggle OFF → fields removed
  await clickNthVertexAISwitch(page, 2);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  const inputsAfterOff = await getInputValues(page);
  const movieProjectAfterOff = inputsAfterOff.filter((i) => i.placeholder === "your-gcp-project-id");
  // Should be only 1 project field left (from image params)
  const movieFieldRemoved = !movieProjectAfterOff.some(
    (f, idx) => idx > 0 && f.value === TEST_PROJECT_ID,
  );
  record(
    "Movie: Toggle OFF → fields removed",
    movieFieldRemoved ? "PASS" : "FAIL",
    movieFieldRemoved ? "Movie Vertex AI fields removed" : "Fields still present",
  );

  // Step 7: Toggle back ON for JSON verification
  await clickNthVertexAISwitch(page, 2);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  record("Movie: Toggle ON for JSON test", "PASS", "Left ON for subsequent tests");
}

/**
 * Test 4: Per-beat Vertex AI settings (requires Pro mode, imagePrompt beat).
 *
 * Per-beat imageParams are in the Text tab's beat editor, under
 * "Advanced Beat Settings" / "ビートの詳細設定" collapsible.
 */
async function testPerBeatVertexAI(page: Page) {
  console.log("\n=== 4. Per-beat Vertex AI Settings ===");

  // Switch to Media tab (where BeatEditor with Advanced Settings lives) using data-testid
  const mediaTab = await page.$('[data-testid="script-editor-tab-media"]');
  if (!mediaTab) {
    record("Per-beat: Switch to Media tab", "WARN", "Media tab not found (data-testid)");
    return;
  }
  await mediaTab.click();
  await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
  record("Per-beat: Switch to Media tab", "PASS", "Clicked via data-testid");
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Find and expand "Advanced Beat Settings" collapsible
  const expanded = await page.evaluate(() => {
    const headings = document.querySelectorAll("h4");
    for (const h4 of headings) {
      const text = h4.textContent?.trim() || "";
      if (text.includes("Advanced Beat Settings") || text.includes("ビートの詳細設定")) {
        // Click the collapsible trigger (parent div with cursor-pointer)
        const trigger = h4.closest("[class*='cursor-pointer']") || h4.parentElement;
        if (trigger) {
          (trigger as HTMLElement).click();
          return true;
        }
      }
    }
    return false;
  });

  if (!expanded) {
    record("Per-beat: Advanced Settings", "WARN", "Collapsible not found – beat may not be imagePrompt type");
    // Return to Style tab for next tests
    await navigateToStyleTab(page);
    return;
  }
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  record("Per-beat: Advanced Settings expanded", "PASS", "Found and expanded");

  // Find the custom imageParams checkbox
  // Label: "Override image generation settings for this Beat" / includes 画像生成 or Override
  const checkboxClicked = await page.evaluate(() => {
    const checkboxes = document.querySelectorAll('[role="checkbox"]');
    for (const cb of checkboxes) {
      const label = cb.closest("div")?.querySelector("label")?.textContent || "";
      if (label.includes("Override") || label.includes("画像生成") || label.includes("このビート")) {
        if (cb.getAttribute("data-state") !== "checked") {
          (cb as HTMLElement).click();
        }
        return true;
      }
    }
    return false;
  });

  if (!checkboxClicked) {
    record("Per-beat: Custom imageParams checkbox", "WARN", "Checkbox not found");
    await navigateToStyleTab(page);
    return;
  }
  // Wait longer for ImageParams component to render
  await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
  record("Per-beat: Enable custom imageParams", "PASS", "Checkbox enabled");

  // Scroll down to make the per-beat ImageParams visible
  await page.evaluate(() => {
    const scrollArea = document.querySelector('[class*="overflow-y-auto"]');
    if (scrollArea) scrollArea.scrollTop = scrollArea.scrollHeight;
  });
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // The per-beat ImageParams component should now be visible with its own provider combobox.
  // Find the provider combobox near the custom imageParams checkbox.
  // BeatStyle layout: <div>(checkbox + label)</div> then <ImageParams> (sibling).
  // We find the checkbox label, get its parent container, then look for a nearby combobox.
  const perBeatProviderIdx = await page.evaluate(() => {
    // Find the checkbox we enabled (by its label text)
    const checkboxes = document.querySelectorAll('[role="checkbox"]');
    for (const cb of checkboxes) {
      const label = cb.closest("div")?.querySelector("label")?.textContent || "";
      if (label.includes("Override") || label.includes("画像生成") || label.includes("このビート")) {
        // Walk up to the BeatStyle root (the div containing both checkbox row and ImageParams)
        const checkboxRow = cb.closest(".flex.items-center.gap-2");
        // The ImageParams is a sibling of the checkbox row's parent
        const beatStyleRoot = checkboxRow?.parentElement;
        if (!beatStyleRoot) continue;
        const combo = beatStyleRoot.querySelector('[role="combobox"]');
        if (combo) {
          const allCombos = document.querySelectorAll('[role="combobox"]');
          for (let i = 0; i < allCombos.length; i++) {
            if (allCombos[i] === combo) return i;
          }
        }
      }
    }
    return -1;
  });

  if (perBeatProviderIdx < 0) {
    record("Per-beat: Provider combobox", "WARN", "Not found near custom imageParams checkbox");
    await navigateToStyleTab(page);
    return;
  }

  await clickComboboxByIndex(page, perBeatProviderIdx);
  const beatGoogleSelected = await selectOption(page, "Google");

  if (!beatGoogleSelected) {
    record("Per-beat: Switch to Google", "WARN", "Could not select Google");
  } else {
    record("Per-beat: Switch to Google", "PASS", "Selected Google for per-beat");
  }

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Count Vertex AI toggles visible on the current page (Media tab).
  // Only the per-beat toggle should be visible here (Style tab toggles are not rendered).
  const toggleCount = await countVertexAIToggles(page);
  record(
    "Per-beat: Vertex AI toggle visible",
    toggleCount >= 1 ? "PASS" : "WARN",
    `${toggleCount} Vertex AI toggle(s) on Media tab (expected ≥1)`,
  );

  if (toggleCount >= 1) {
    // Toggle the 1st (per-beat) Vertex AI switch ON
    const toggled = await clickNthVertexAISwitch(page, 1);
    record("Per-beat: Toggle ON", toggled ? "PASS" : "FAIL", toggled ? "Clicked" : "Failed");

    if (toggled) {
      // Verify pre-fill from Settings
      const inputs = await getInputValues(page);
      const beatProjectFields = inputs.filter((i) => i.placeholder === "your-gcp-project-id");
      const hasBeatProject = beatProjectFields.some((f) => f.value === TEST_PROJECT_ID);
      record(
        "Per-beat: Pre-filled project ID",
        hasBeatProject ? "PASS" : "WARN",
        hasBeatProject
          ? `Found "${TEST_PROJECT_ID}"`
          : `Values: ${beatProjectFields.map((f) => f.value).join(", ")}`,
      );

      // Toggle OFF
      await clickNthVertexAISwitch(page, 1);
      await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

      // After toggle OFF, the switch should be unchecked and project input fields should be gone
      const switchesAfterOff = await getSwitchStates(page);
      const vertexSwitchAfterOff = switchesAfterOff.find((s) => s.label.includes("Vertex AI"));
      record(
        "Per-beat: Toggle OFF → unchecked",
        vertexSwitchAfterOff && !vertexSwitchAfterOff.checked ? "PASS" : "WARN",
        vertexSwitchAfterOff ? `checked=${vertexSwitchAfterOff.checked}` : "Switch not found",
      );
    }
  }

  // Disable custom imageParams to clean up
  await page.evaluate(() => {
    const checkboxes = document.querySelectorAll('[role="checkbox"]');
    for (const cb of checkboxes) {
      const label = cb.closest("div")?.querySelector("label")?.textContent || "";
      if (
        (label.includes("Override") || label.includes("画像生成") || label.includes("このビート")) &&
        cb.getAttribute("data-state") === "checked"
      ) {
        (cb as HTMLElement).click();
        return;
      }
    }
  });
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Return to Style tab for subsequent tests
  await navigateToStyleTab(page);
}

/**
 * Test 5: JSON reflection (UI → JSON).
 */
async function testJsonReflection(page: Page) {
  console.log("\n=== 5. JSON Editor - UI → JSON ===");

  // Switch to JSON tab
  const jsonClicked = await clickTabByText(page, "JSON");
  record("Switch to JSON tab", jsonClicked ? "PASS" : "FAIL", jsonClicked ? "Clicked" : "Not found");
  if (!jsonClicked) return;

  await page.waitForTimeout(CONFIG.EDITOR_LOAD_DELAY_MS);

  const json = await readEditorJson(page);
  if (!json) {
    record("Read JSON", "FAIL", "Could not read/parse editor content");
    return;
  }
  record("Read JSON", "PASS", "Successfully parsed");

  // Check imageParams
  const presentationStyle = json.presentationStyle as Record<string, unknown> | undefined;
  const imageParams = (presentationStyle?.imageParams || json.imageParams) as Record<string, unknown> | undefined;

  record(
    "JSON: imageParams.provider",
    imageParams?.provider === "google" ? "PASS" : "FAIL",
    `provider="${imageParams?.provider}"`,
  );
  record(
    "JSON: imageParams.vertexai_project",
    imageParams?.vertexai_project === TEST_PROJECT_ID ? "PASS" : "WARN",
    `vertexai_project="${imageParams?.vertexai_project}"`,
  );
  record(
    "JSON: imageParams.vertexai_location",
    imageParams?.vertexai_location === TEST_LOCATION ? "PASS" : "WARN",
    `vertexai_location="${imageParams?.vertexai_location}"`,
  );

  // Check movieParams
  const movieParams = (presentationStyle?.movieParams || json.movieParams) as Record<string, unknown> | undefined;
  record(
    "JSON: movieParams.provider",
    movieParams?.provider === "google" ? "PASS" : "WARN",
    `provider="${movieParams?.provider}"`,
  );
  record(
    "JSON: movieParams.vertexai_project",
    movieParams?.vertexai_project === TEST_PROJECT_ID ? "PASS" : "WARN",
    `vertexai_project="${movieParams?.vertexai_project}"`,
  );
  record(
    "JSON: movieParams.vertexai_location",
    movieParams?.vertexai_location === TEST_LOCATION ? "PASS" : "WARN",
    `vertexai_location="${movieParams?.vertexai_location}"`,
  );
}

/**
 * Test 6: JSON → UI reflection.
 */
async function testJsonToUI(page: Page) {
  console.log("\n=== 6. JSON → UI Reflection ===");

  // We should be on the JSON tab from the previous test.
  const json = await readEditorJson(page);
  if (!json) {
    record("Read JSON for edit", "FAIL", "Could not read editor content");
    return;
  }

  // Modify imageParams via JSON
  const imageParams = (json.imageParams || {}) as Record<string, unknown>;
  imageParams.provider = "google";
  imageParams.vertexai_project = JSON_EDIT_PROJECT_ID;
  imageParams.vertexai_location = JSON_EDIT_LOCATION;
  json.imageParams = imageParams;

  // Write modified JSON back
  const written = await writeEditorJson(page, json);
  record("Write modified JSON", written ? "PASS" : "FAIL", written ? "Written" : "Failed");
  if (!written) return;

  // Switch to Style tab
  const styleClicked = await navigateToStyleTab(page);
  record("Switch to Style tab", styleClicked ? "PASS" : "FAIL", styleClicked ? "Clicked" : "Not found");
  if (!styleClicked) return;

  await scrollToImageParams(page);
  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Verify provider is Google
  const imgProvIdx = await findImageProviderIndex(page);
  const comboTexts = await getComboboxTexts(page);
  const providerText = imgProvIdx >= 0 ? comboTexts[imgProvIdx] : "";
  record("JSON→UI: Provider is Google", providerText === "Google" ? "PASS" : "FAIL", `Provider="${providerText}"`);

  // Verify Vertex AI toggle is ON
  const switches = await getSwitchStates(page);
  const vertexToggle = switches.find((s) => s.label.includes("Vertex AI"));
  record(
    "JSON→UI: Vertex AI toggle ON",
    vertexToggle?.checked ? "PASS" : "FAIL",
    vertexToggle ? `checked=${vertexToggle.checked}` : "Not found",
  );

  // Verify field values
  const inputs = await getInputValues(page);
  const projectField = inputs.find((i) => i.placeholder === "your-gcp-project-id");
  const locationField = inputs.find((i) => i.placeholder === "us-central1");

  record(
    "JSON→UI: Project ID reflected",
    projectField?.value === JSON_EDIT_PROJECT_ID ? "PASS" : "FAIL",
    `Expected "${JSON_EDIT_PROJECT_ID}", got "${projectField?.value || "(not found)"}"`,
  );
  record(
    "JSON→UI: Location reflected",
    locationField?.value === JSON_EDIT_LOCATION ? "PASS" : "FAIL",
    `Expected "${JSON_EDIT_LOCATION}", got "${locationField?.value || "(not found)"}"`,
  );
}

/**
 * Test 7: Provider switch hides toggle.
 */
async function testProviderSwitchHidesToggle(page: Page) {
  console.log("\n=== 7. Provider Switch Hides Toggle ===");

  const styleClicked = await navigateToStyleTab(page);
  if (!styleClicked) {
    record("Switch to Style tab", "FAIL", "Tab not found");
    return;
  }

  await scrollToImageParams(page);

  // Switch image provider to OpenAI
  const imgProvIdx = await findImageProviderIndex(page);
  if (imgProvIdx >= 0) {
    await clickComboboxByIndex(page, imgProvIdx);
    const selected = await selectOption(page, "OpenAI");
    record("Switch image to OpenAI", selected ? "PASS" : "FAIL", selected ? "Selected" : "Failed");
    if (!selected) return;
  }

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
  await scrollToImageParams(page);

  // Verify image Vertex AI toggle is gone
  const toggleCount = await countVertexAIToggles(page);
  record(
    "Img: Vertex AI hidden after OpenAI",
    toggleCount <= 1 ? "PASS" : "FAIL",
    `${toggleCount} Vertex AI toggle(s) remaining`,
  );

  // Switch movie provider away from Google (movie has Replicate, not OpenAI)
  await scrollToMovieParams(page);
  const movieProvIdx = await findMovieProviderIndex(page);
  if (movieProvIdx >= 0) {
    await clickComboboxByIndex(page, movieProvIdx);
    const selected = await selectOption(page, "Replicate");
    record("Switch movie to Replicate", selected ? "PASS" : "FAIL", selected ? "Selected" : "Failed");
  }

  await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

  // Verify all Vertex AI toggles are gone
  const finalToggleCount = await countVertexAIToggles(page);
  record(
    "All Vertex AI toggles hidden",
    finalToggleCount === 0 ? "PASS" : "FAIL",
    `${finalToggleCount} Vertex AI toggle(s) remaining`,
  );
}

/**
 * Test 8: Console health.
 */
async function testConsoleHealth(monitor: ConsoleMonitor) {
  console.log("\n=== 8. Console Health ===");
  record("Console errors", monitor.errors.length === 0 ? "PASS" : "WARN", `${monitor.errors.length} error(s) total`);
  if (monitor.errors.length > 0) {
    console.log(`    Errors: ${monitor.errors.slice(0, 5).join("; ")}`);
  }
}

// --- Main ---

(async () => {
  console.log("========================================");
  console.log("  Vertex AI Support QA Test Suite");
  console.log(`  ${timestamp}`);
  console.log("========================================\n");

  const resources: { browser: Browser | null } = { browser: null };
  let exitCode = 1;

  try {
    resources.browser = await connectCDP();
    const contexts = resources.browser.contexts();

    if (contexts.length === 0) {
      throw new Error("No browser contexts found");
    }

    const page = findAppPage(contexts);
    console.log(`App page: ${page.url()}`);

    // Start console monitoring
    const monitor = createConsoleMonitor(page);
    monitor.start();

    // Navigate to home first
    await page.goto(page.url().split("#")[0] + "#/");
    await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);

    // Dismiss any open modal/dialog overlay (e.g., onboarding modal)
    const overlay = await page.$('[data-state="open"][aria-hidden="true"]');
    if (overlay) {
      console.log("Dismissing open modal overlay...");
      await page.keyboard.press("Escape");
      await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
    }

    // --- Test 1a: Settings – blank defaults ---
    await testSettingsBlankDefaults(page);

    // --- Ensure Pro mode for per-beat tests ---
    await ensureProMode(page);

    // --- Create test project ---
    console.log("\n--- Creating test project ---");
    const newBtn = await page.$('[data-testid="create-new-button"]');
    if (newBtn) {
      await newBtn.click();
      await page.waitForTimeout(CONFIG.PROJECT_CREATE_DELAY_MS);
      const url = page.url();
      record("Test project created", url.includes("#/project/") ? "PASS" : "FAIL", `URL: ${url}`);

      // Set project title and description via JSON editor
      const jsonTabClicked = await clickTabByText(page, "JSON");
      if (jsonTabClicked) {
        await page.waitForTimeout(CONFIG.EDITOR_LOAD_DELAY_MS);
        const json = await readEditorJson(page);
        if (json) {
          json.title = TEST_PROJECT_TITLE;
          json.description = TEST_PROJECT_DESCRIPTION;
          const written = await writeEditorJson(page, json);
          record(
            "Set project title/description",
            written ? "PASS" : "FAIL",
            written ? `Title: "${TEST_PROJECT_TITLE}"` : "Failed to write JSON",
          );
        }
        // Switch to Style tab
        await navigateToStyleTab(page);
        await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);
      }
    } else {
      const firstProject = await page.$('a[href*="project"]');
      if (firstProject) {
        await firstProject.click();
        await page.waitForTimeout(CONFIG.NAVIGATION_DELAY_MS);
      }
    }

    // --- Test 2: Image Params (includes 1b Settings set values) ---
    await testImageParamsVertexAI(page);

    // --- Test 3: Movie Params ---
    await testMovieParamsVertexAI(page);

    // --- Test 4: Per-beat Vertex AI ---
    await testPerBeatVertexAI(page);

    // --- Test 5: JSON Reflection (UI → JSON) ---
    await testJsonReflection(page);

    // --- Test 6: JSON → UI Reflection ---
    await testJsonToUI(page);

    // --- Test 7: Provider Switch Hides Toggle ---
    await testProviderSwitchHidesToggle(page);

    // --- Test 8: Console Health ---
    await testConsoleHealth(monitor);

    monitor.stop();

    // Navigate back to home
    await page.goto(page.url().split("#")[0] + "#/");
    await page.waitForTimeout(CONFIG.ACTION_DELAY_MS);

    // --- Summary ---
    console.log("\n========================================");
    console.log("  TEST SUMMARY");
    console.log("========================================");

    const pass = results.filter((r) => r.status === "PASS").length;
    const fail = results.filter((r) => r.status === "FAIL").length;
    const warn = results.filter((r) => r.status === "WARN").length;

    console.log(`  PASS: ${pass}`);
    console.log(`  FAIL: ${fail}`);
    console.log(`  WARN: ${warn}`);
    console.log(`  TOTAL: ${results.length}`);
    console.log("----------------------------------------");

    if (fail > 0) {
      console.log("\n  Failed tests:");
      results.filter((r) => r.status === "FAIL").forEach((r) => console.log(`    ✗ ${r.name}: ${r.detail}`));
    }

    exitCode = fail === 0 ? 0 : 1;
    console.log("\n========================================");
  } catch (error) {
    console.error("\nTest suite failed:", error);
    exitCode = 1;
  } finally {
    if (resources.browser) {
      await resources.browser.close().catch(() => {});
    }
    process.exit(exitCode);
  }
})();
