<template>
  <Layout>
    <TooltipProvider>
      <div class="mx-auto max-w-[95%] space-y-6 p-6">
        <!-- Header Section -->
        <ProjectHeader
          :mulmoScript="mulmoScriptHistoryStore.currentMulmoScript"
          :isDevelopment="isDevelopment"
          @openProjectFolder="openProjectFolder"
          @updateMulmoScript="handleUpdateScriptFromHeader"
        />

        <!-- 3 Split Layout -->
        <div class="relative grid h-auto grid-cols-1 gap-4 lg:h-[calc(100vh-180px)]" :class="gridLayoutClass">
          <!-- Left Column - AI Chat -->
          <div
            class="h-full overflow-y-auto pr-2"
            :class="{ 'lg:block': isLeftColumnOpen, 'lg:hidden': !isLeftColumnOpen }"
          >
            <Card class="flex h-full flex-col border-blue-200 bg-gradient-to-r from-blue-50 to-indigo-50">
              <CardHeader class="flex-shrink-0">
                <div class="flex items-center justify-between">
                  <div>
                    <CardTitle class="flex items-center space-x-2 text-blue-700">
                      <Bot :size="20" />
                      <span>
                        {{ t("project.chat.title") }}
                      </span>
                    </CardTitle>
                    <p class="text-sm text-blue-600">
                      {{ t("project.chat.beginnerDescription") }}
                    </p>
                  </div>
                  <Button variant="ghost" size="sm" @click="isLeftColumnOpen = false" class="hidden lg:inline-flex">
                    <PanelLeftClose :size="16" />
                  </Button>
                </div>
              </CardHeader>
              <CardContent class="-mt-6 flex flex-1 flex-col overflow-hidden" v-if="projectMetadata">
                <Chat
                  :mulmoScript="mulmoScriptHistoryStore.currentMulmoScript"
                  :messages="projectMetadata?.chatMessages"
                  @update:updateChatMessages="handleUpdateChatMessages"
                  @update:updateMulmoScript="handleUpdateScript"
                  @resetMediaFiles="resetMediaFiles"
                  class="flex h-full flex-col"
                />
              </CardContent>
            </Card>
          </div>

          <!-- Left Column - Collapsed State -->
          <div v-if="!isLeftColumnOpen" class="hidden h-full w-[48px] border-r border-gray-200 bg-gray-100 lg:flex">
            <button
              @click="isLeftColumnOpen = true"
              class="flex h-full w-full flex-col items-center p-2 transition-colors hover:bg-gray-200"
              :aria-label="t('project.chat.openPanel')"
              :title="t('project.chat.openPanel')"
            >
              <PanelLeftOpen :size="16" class="mt-2 mb-4 text-gray-600" />
              <Bot :size="20" class="mb-2 text-blue-700" />
              <span class="writing-mode-vertical text-sm text-gray-600">{{ t("project.chat.title") }}</span>
            </button>
          </div>

          <!-- Middle Column - Script Editor -->
          <div class="h-full">
            <Collapsible class="h-full">
              <Card class="flex h-full flex-col">
                <CardHeader class="flex-shrink-0">
                  <div class="flex items-center justify-between">
                    <CollapsibleTrigger as-child>
                      <CardTitle class="flex cursor-pointer items-center space-x-2">
                        <ScrollText :size="20" />
                        <span>{{ t("project.menu.script") }}</span>
                      </CardTitle>
                    </CollapsibleTrigger>
                    <div class="flex items-center space-x-2">
                      <!-- Validation Status -->
                      <div class="flex items-center space-x-2">
                        <div v-if="isValidScriptData" class="group relative">
                          <CheckCircle :size="16" class="cursor-pointer text-green-500 group-hover:text-green-600" />
                          <span
                            class="pointer-events-none absolute bottom-full left-1/2 mb-2 -translate-x-1/2 transform rounded bg-gray-800 px-2 py-1 text-xs whitespace-nowrap text-white opacity-0 transition-opacity duration-200 group-hover:opacity-100"
                          >
                            {{ t("project.scriptEditor.validationStatus") }}
                          </span>
                        </div>
                        <XCircle v-if="!isValidScriptData" :size="16" class="text-red-500" />
                      </div>
                      <!-- Undo/Redo buttons -->
                      <Button
                        variant="ghost"
                        size="sm"
                        :disabled="!mulmoScriptHistoryStore.undoable"
                        @click="mulmoScriptHistoryStore.undo"
                      >
                        <Undo :size="16" :class="mulmoScriptHistoryStore.undoable ? 'text-black' : 'text-gray-400'" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        :disabled="!mulmoScriptHistoryStore.redoable"
                        @click="mulmoScriptHistoryStore.redo"
                      >
                        <Redo :size="16" :class="mulmoScriptHistoryStore.redoable ? 'text-black' : 'text-gray-400'" />
                      </Button>
                    </div>
                  </div>
                </CardHeader>
                <CardContent class="h-full">
                  <ScriptEditor
                    :mulmoValue="mulmoScriptHistoryStore.currentMulmoScript ?? {}"
                    :imageFiles="imageFiles"
                    :movieFiles="movieFiles"
                    :audioFiles="audioFiles"
                    :lipSyncFiles="lipSyncFiles"
                    :scriptEditorActiveTab="projectMetadata?.scriptEditorActiveTab"
                    @update:mulmoValue="mulmoScriptHistoryStore.updateMulmoScript"
                    :isValidScriptData="isValidScriptData"
                    @update:isValidScriptData="(val) => (isValidScriptData = val)"
                    @generateImage="generateImage"
                    @formatAndPushHistoryMulmoScript="formatAndPushHistoryMulmoScript"
                    @update:scriptEditorActiveTab="handleUpdateScriptEditorActiveTab"
                    :mulmoError="mulmoError"
                    @saveMulmo="saveMulmo"
                  />
                </CardContent>
              </Card>
            </Collapsible>
          </div>

          <!-- Right Column - Output & Product -->
          <div
            class="space-y-4 overflow-y-auto pl-2"
            :class="{ 'lg:block': isRightColumnOpen, 'lg:hidden': !isRightColumnOpen }"
          >
            <!-- Output Section -->
            <Card>
              <CardHeader>
                <div class="flex items-center justify-between">
                  <CardTitle class="flex items-center space-x-2">
                    <Settings :size="20" />
                    <span>{{ t("project.generate.outputSettingsGeneration") }}</span>
                  </CardTitle>
                  <Button variant="ghost" size="sm" @click="isRightColumnOpen = false" class="hidden lg:inline-flex">
                    <PanelRightClose :size="16" />
                  </Button>
                </div>
              </CardHeader>
              <CardContent class="p-4">
                <Generate :projectId="projectId" />
              </CardContent>
            </Card>

            <!-- Product Section -->
            <Card>
              <CardHeader>
                <CardTitle class="flex items-center space-x-2">
                  <Play :size="20" />
                  <span>{{ t("project.menu.product") }}</span>
                </CardTitle>
              </CardHeader>
              <CardContent>
                <MulmoViewer
                  v-if="project"
                  :project="project"
                  :mulmoViewerActiveTab="projectMetadata?.mulmoViewerActiveTab"
                  @update:mulmoViewerActiveTab="handleUpdateMulmoViewerActiveTab"
                />
              </CardContent>
            </Card>

            <!-- Debug Log Section -->
            <Card>
              <CardContent class="space-y-4 p-4">
                <!-- Debug Logs -->
                <div class="rounded-lg bg-gray-50 p-4">
                  <div class="mb-2 flex items-center justify-between">
                    <h3 class="text-sm font-medium">{{ t("project.menu.debugLog") }}</h3>
                    <Button
                      @click="copyDebugLogs"
                      size="sm"
                      variant="outline"
                      :disabled="!debugLog || debugLog.length === 0"
                      class="gap-2"
                    >
                      <Copy class="h-3 w-3" />
                      {{ t("ui.actions.copy") }}
                    </Button>
                  </div>
                  <div class="h-40 overflow-y-auto rounded border bg-white p-2 font-mono text-xs" ref="logContainer">
                    <div v-for="(entry, i) in debugLog" :key="'debug-' + i" class="whitespace-pre-wrap">
                      {{ entry }}
                    </div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>

          <!-- Right Column - Collapsed State -->
          <div v-if="!isRightColumnOpen" class="hidden h-full w-[48px] border-l border-gray-200 bg-gray-100 lg:flex">
            <button
              @click="isRightColumnOpen = true"
              class="flex h-full w-full flex-col items-center p-2 transition-colors hover:bg-gray-200"
              :aria-label="t('project.generate.openPanel')"
              :title="t('project.generate.openPanel')"
            >
              <PanelRightOpen :size="16" class="mt-2 mb-4 text-gray-600" />
              <Settings :size="20" class="mb-2 text-gray-700" />
              <span class="writing-mode-vertical text-sm text-gray-600">{{ t("project.generate.outputProduct") }}</span>
            </button>
          </div>
        </div>
      </div>
    </TooltipProvider>
  </Layout>
</template>

<script setup lang="ts">
import { ref, computed, watch, onMounted, onUnmounted } from "vue";
import { useDebounceFn } from "@vueuse/core";
import { useRoute, useRouter } from "vue-router";
import { useI18n } from "vue-i18n";

import {
  ScrollText,
  Settings,
  Play,
  Undo,
  Redo,
  CheckCircle,
  XCircle,
  Bot,
  PanelLeftClose,
  PanelLeftOpen,
  PanelRightClose,
  PanelRightOpen,
  Copy,
} from "lucide-vue-next";
import dayjs from "dayjs";
import { mulmoScriptSchema, type MulmoScript } from "mulmocast/browser";

import { Button } from "@/components/ui";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
// import { Separator } from "@/components/ui/separator"; // Will be used for mobile layout
import { Collapsible, CollapsibleTrigger } from "@/components/ui/collapsible";
import { TooltipProvider } from "@/components/ui/tooltip";

// Import sub-components (to be created)
import Layout from "@/components/layout.vue";
import Chat from "./project/chat.vue";
import ScriptEditor from "./project/script_editor.vue";
import Generate from "./project/generate.vue";
import MulmoViewer from "../components/mulmo_viewer/mulmo_viewer.vue";
import ProjectHeader from "./project/project_header.vue";

import { getConcurrentTaskStatusMessageComponent } from "./project/concurrent_task_status_message";

import { projectApi, type ProjectMetadata } from "@/lib/project_api";
import { notifySuccess, notifyProgress, notifyError } from "@/lib/notification";
import { setRandomBeatId } from "@/lib/beat_util.js";
import { bufferToUrl } from "@/lib/utils";

import { useMulmoEventStore, useMulmoScriptHistoryStore, useGraphAIDebugLogStore } from "../store";

import { isLeftColumnOpen, isRightColumnOpen, gridLayoutClass } from "./project/composable/style";
import { ChatMessage, MulmoError } from "@/types";
import { type ScriptEditorTab, type MulmoViewerTab } from "../../shared/constants";

import { zodError2MulmoError } from "../lib/error";

// State
const route = useRoute();
const router = useRouter();
const { t } = useI18n();

const mulmoEventStore = useMulmoEventStore();
const mulmoScriptHistoryStore = useMulmoScriptHistoryStore();

const projectId = computed(() => route.params.id as string);
const projectMetadata = ref<ProjectMetadata | null>(null);
const project = computed(() => ({
  metadata: projectMetadata.value,
  script: mulmoScriptHistoryStore.currentMulmoScript,
}));

const isDevelopment = import.meta.env.DEV;

const graphAIDebugStore = useGraphAIDebugLogStore();

// Load project data on mount
onMounted(async () => {
  downloadAudioFiles();
  downloadImageFiles();

  try {
    projectMetadata.value = await projectApi.getProjectMetadata(projectId.value);
    const data = await projectApi.getProjectMulmoScript(projectId.value);
    data.beats.map(setRandomBeatId);
    mulmoScriptHistoryStore.initMulmoScript(data);
  } catch (error) {
    console.error("Failed to load project:", error);
    router.push("/");
  }
});

onUnmounted(() => {
  mulmoScriptHistoryStore.resetMulmoScript();
});

const handleUpdateScript = (script: MulmoScript) => {
  mulmoScriptHistoryStore.updateMulmoScript(script);
  notifySuccess(t("settings.notifications.createSuccess"));
};

const handleUpdateScriptFromHeader = (script: MulmoScript) => {
  mulmoScriptHistoryStore.updateMulmoScript(script);
};

const saveProjectMetadata = useDebounceFn(async (projectMetadata: ProjectMetadata) => {
  await projectApi.saveProjectMetadata(projectId.value, {
    ...projectMetadata,
    updatedAt: dayjs().toISOString(),
  });
}, 1000);

const handleUpdateChatMessages = (messages: ChatMessage[]) => {
  projectMetadata.value.chatMessages = messages;
  saveProjectMetadata(projectMetadata.value);
};

const handleUpdateScriptEditorActiveTab = (tab: ScriptEditorTab) => {
  projectMetadata.value.scriptEditorActiveTab = tab;
  saveProjectMetadata(projectMetadata.value);
};

const handleUpdateMulmoViewerActiveTab = (tab: MulmoViewerTab) => {
  projectMetadata.value.mulmoViewerActiveTab = tab;
  saveProjectMetadata(projectMetadata.value);
};

const saveMulmo = async () => {
  console.log("saved", mulmoScriptHistoryStore.currentMulmoScript);
  await projectApi.saveProjectScript(projectId.value, mulmoScriptHistoryStore.currentMulmoScript);
  projectMetadata.value.updatedAt = dayjs().toISOString();
  await projectApi.saveProjectMetadata(projectId.value, projectMetadata.value);
};
const saveMulmoScript = useDebounceFn(saveMulmo, 1000);

watch(
  () => mulmoScriptHistoryStore.currentMulmoScript,
  (newVal, oldVal) => {
    // Skip saving when first watch
    if (oldVal === null) {
      return;
    }
    saveMulmoScript(mulmoScriptHistoryStore.currentMulmoScript);
  },
  { deep: true },
);

const mulmoError = computed<MulmoError>(() => {
  const zodError = mulmoScriptSchema.safeParse(mulmoScriptHistoryStore.currentMulmoScript);
  if (!zodError.success) {
    return zodError2MulmoError(zodError.error);
  }
  return null;
});

const formatAndPushHistoryMulmoScript = () => {
  const data = mulmoScriptSchema.safeParse(mulmoScriptHistoryStore.currentMulmoScript);
  if (data.success) {
    data.data.beats.map(setRandomBeatId);
    mulmoScriptHistoryStore.updateMulmoScriptAndPushToHistory(data.data);
    // push store //
  }
  console.log(data);
};

const ConcurrentTaskStatusMessageComponent = getConcurrentTaskStatusMessageComponent(projectId.value ?? "");

const openProjectFolder = async () => {
  await projectApi.openProjectFolder(projectId.value);
};

const generateImage = async (index: number, target: string) => {
  await saveMulmo();
  notifyProgress(window.electronAPI.mulmoHandler("mulmoImageGenerate", projectId.value, index, target), {
    loadingMessage: ConcurrentTaskStatusMessageComponent,
    successMessage: t("notify.image.successMessage"),
    errorMessage: t("notify.image.errorMessage"),
  });
};

const audioFiles = ref<Record<string, string | null>>({});
const imageFiles = ref<Record<string, string | null>>({});
const movieFiles = ref<Record<string, string | null>>({});
const lipSyncFiles = ref<Record<string, string | null>>({});

const resetMediaFiles = () => {
  audioFiles.value = {};
  imageFiles.value = {};
  movieFiles.value = {};
  lipSyncFiles.value = {};
};

const downloadAudioFiles = async () => {
  console.log("audioFiles");
  const res = (await window.electronAPI.mulmoHandler("mulmoAudioFiles", projectId.value)) as Buffer[];
  audioFiles.value = Object.entries(res).reduce((tmp, [k, v]) => {
    if (v) {
      tmp[k] = bufferToUrl(v, "audio/mp3");
    }
    return tmp;
  }, {});
};

const downloadImageFiles = async () => {
  const res = await window.electronAPI.mulmoHandler("mulmoImageFiles", projectId.value);
  Object.keys(res).forEach((id) => {
    const data = res[id];
    if (data.imageData) {
      imageFiles.value[id] = bufferToUrl(data.imageData, "image/png");
    }
    if (data.movieData) {
      movieFiles.value[id] = bufferToUrl(data.movieData, "video/mp4");
    }
    if (data.lipSyncData) {
      lipSyncFiles.value[id] = bufferToUrl(data.lipSyncData, "video/mp4");
    }
  });
};

const isValidScriptData = ref(true);

const logContainer = ref<HTMLElement | null>(null);

watch(
  () => mulmoEventStore.mulmoEvent[projectId.value],
  async (mulmoEvent) => {
    // generate image
    if (mulmoEvent && mulmoEvent.kind === "session" && mulmoEvent.sessionType === "image" && !mulmoEvent.inSession) {
      downloadImageFiles();
    }

    if (mulmoEvent && mulmoEvent.kind === "session" && mulmoEvent.sessionType === "audio" && !mulmoEvent.inSession) {
      downloadAudioFiles();
    }

    // beats
    if (mulmoEvent?.kind === "beatGenerate" && ["image"].includes(mulmoEvent.sessionType) && !mulmoEvent.inSession) {
      const index = mulmoScriptHistoryStore.currentMulmoScript.beats.findIndex((beat) => beat.id === mulmoEvent.id);
      if (index === -1) {
        return;
      }
      const data: { imageData?: Buffer; movieData?: Buffer } = await window.electronAPI.mulmoHandler(
        "mulmoImageFile",
        projectId.value,
        index,
      );
      if (data?.imageData) {
        imageFiles.value[mulmoEvent.id] = bufferToUrl(data.imageData, "image/png");
      }
      if (data?.movieData) {
        movieFiles.value[mulmoEvent.id] = bufferToUrl(data.movieData, "video/mp4");
      }
      if (data?.lipSyncData) {
        lipSyncFiles.value[mulmoEvent.id] = bufferToUrl(data.lipSyncData, "video/mp4");
      }
      return "";
    }
    if (mulmoEvent?.kind === "beat" && mulmoEvent.sessionType === "audio" && !mulmoEvent.inSession) {
      const index = mulmoScriptHistoryStore.currentMulmoScript.beats.findIndex((beat) => beat.id === mulmoEvent.id);
      if (index === -1) {
        return;
      }
      const res = (await window.electronAPI.mulmoHandler("mulmoAudioFile", projectId.value, index)) as Buffer;
      if (res) {
        audioFiles.value[mulmoEvent.id] = bufferToUrl(res, "audio/mp3");
      }
    }
    console.log(mulmoEvent);
  },
  { immediate: true },
);

const debugLog = computed(() => graphAIDebugStore.graphaiDebugLog[projectId.value]);

watch(
  () => debugLog,
  () => {
    logContainer.value?.scrollTo({ top: logContainer.value.scrollHeight });
  },
  { deep: true },
);

// Copy debug logs to clipboard
const copyDebugLogs = async () => {
  if (!debugLog.value || debugLog.value.length === 0) return;

  // Build logsText by mapping entries to strings, pretty-printing non-strings
  const logsText = debugLog.value
    .map((item) => {
      if (typeof item === "string") {
        return item;
      }
      // Pretty-print non-string entries
      return JSON.stringify(item, null, 2);
    })
    .join("\n");

  // Try multiple clipboard methods in order of preference
  let copySucceeded = false;

  // Method 1: Try navigator.clipboard.writeText (modern browsers)
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(logsText);
      copySucceeded = true;
    } catch (error) {
      console.warn("navigator.clipboard.writeText failed:", error);
    }
  }

  // Method 2: Try Electron clipboard API if available
  if (!copySucceeded && window.electronAPI?.clipboard) {
    try {
      await window.electronAPI.clipboard.writeText(logsText);
      copySucceeded = true;
    } catch (error) {
      console.warn("Electron clipboard API failed:", error);
    }
  }

  // Method 3: Fallback to document.execCommand (older browsers, insecure contexts)
  if (!copySucceeded) {
    try {
      const textarea = document.createElement("textarea");
      textarea.value = logsText;
      textarea.style.position = "fixed";
      textarea.style.left = "-999999px";
      textarea.style.top = "-999999px";
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();

      copySucceeded = document.execCommand("copy");

      document.body.removeChild(textarea);
    } catch (error) {
      console.error("document.execCommand('copy') failed:", error);
    }
  }

  // Show appropriate feedback
  if (copySucceeded) {
    notifySuccess(t("settings.notifications.copiedToClipboard"));
  } else {
    notifyError(t("settings.notifications.copyFailed"));
  }
};
</script>

<style scoped>
.writing-mode-vertical {
  writing-mode: vertical-rl;
  text-orientation: sideways;
}
</style>
